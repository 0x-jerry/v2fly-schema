{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": {},
    "definitions": {
        "AllocateObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"strategy\": \"always\",\n  \"refresh\": 5,\n  \"concurrency\": 3\n}\n```",
            "properties": {
                "concurrency": {
                    "description": "随机端口数量。最小值为 `1`，最大值为 `port` 范围的三分之一。建议值为 `3`。",
                    "type": "number"
                },
                "refresh": {
                    "description": "随机端口刷新间隔，单位为分钟。最小值为 `2`，建议值为 `5`。这个属性仅当 `strategy` 设置为 `\"random\"` 时有效。",
                    "type": "number"
                },
                "strategy": {
                    "description": "端口分配策略。\n- `\"always\"` 表示总是分配所有已指定的端口，`port` 中指定了多少个端口，Xray 就会监听这些端口。\n- `\"random\"` 表示随机开放端口，每隔 `refresh` 分钟在 `port` 范围中随机选取 `concurrency` 个端口来监听。",
                    "enum": [
                        "always",
                        "random"
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ApiObject": {
            "additionalProperties": {},
            "description": "`ApiObject` 对应配置文件的 `api` 项。\n```json\n{\n  \"api\": {\n    \"tag\": \"api\",\n    \"listen\": \"127.0.0.1:8080\",\n    \"services\": [\"HandlerService\", \"LoggerService\", \"StatsService\", \"RoutingService\"]\n  }\n}\n```",
            "properties": {
                "listen": {
                    "description": "API 服务监听的 IP 和端口。这是一个可选配置项。\n省略这项时需要按照下面[相关配置](#相关配置)中的示例，添加 inbounds 和 routing 配置。",
                    "type": "string"
                },
                "services": {
                    "description": "开启的 API 列表，可选的值见 [API 列表](#支持的-api-列表)。\n可以在 inbounds 配置中增加一个 api 的 inbound\n```json\n\"inbounds\": [\n  {\n    \"listen\": \"127.0.0.1\",\n    \"port\": 10085,\n    \"protocol\": \"dokodemo-door\",\n    \"settings\": {\n      \"address\": \"127.0.0.1\"\n    },\n    \"tag\": \"api\"\n  }\n]\n```\n在路由配置中增加针对 api inbound 的路由规则\n```json\n\"routing\": {\n  \"rules\": [\n    {\n      \"inboundTag\": [\n        \"api\"\n      ],\n      \"outboundTag\": \"api\",\n      \"type\": \"field\"\n    }\n  ]\n}\n```\n在基础配置中增加 api\n```json\n\"api\": {\n  \"tag\": \"api\",\n  \"services\": [\n    \"StatsService\"\n  ]\n}\n```",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "tag": {
                    "description": "出站代理标识。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BalancerObject": {
            "additionalProperties": {},
            "description": "负载均衡器配置。当一个负载均衡器生效时，它会从指定的 outbound 中，按配置选出一个最合适的 outbound，进行流量转发。\n```json\n{\n  \"tag\": \"balancer\",\n  \"selector\": [],\n  \"fallbackTag\": \"outbound\",\n  \"strategy\": {}\n}\n```",
            "properties": {
                "fallbackTag": {
                    "description": "如果根据连接观测结果所有 outbound 都无法连接，则使用这个配置项指定的 outbound。\n注意：需要添加 [observatory](./observatory.md#observatoryobject) 或者 [burstObservatory](./observatory.md#burstobservatoryobject) 配置项",
                    "type": "string"
                },
                "selector": {
                    "description": "一个字符串数组，其中每一个字符串将用于和 outbound 标识的前缀匹配。在以下几个 outbound 标识中：`[ \"a\", \"ab\", \"c\", \"ba\" ]`，`\"selector\": [\"a\"]` 将匹配到 `[ \"a\", \"ab\" ]`。\n一般匹配到多个 outbound，使他们均衡的承担负载。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "strategy": {
                    "$ref": "#/definitions/StrategyObject"
                },
                "tag": {
                    "description": "此负载均衡器的标识，用于匹配 `RuleObject` 中的 `balancerTag`。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BridgeObject": {
            "additionalProperties": {},
            "description": "```jsonc\n{\n  \"tag\": \"bridge\",\n  \"domain\": \"reverse-proxy.xray.internal\"\n}\n```",
            "properties": {
                "domain": {
                    "description": "指定一个域名，`bridge` 向 `portal` 建立的连接，都会借助这个域名进行发送。\n这个域名只作为 `bridge` 和 `portal` 的通信用途，不必真实存在。",
                    "type": "string"
                },
                "tag": {
                    "description": "所有由 `bridge` 发出的连接，都会带有这个标识。可以在 [路由配置](./routing.md) 中使用 `inboundTag` 进行识别。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "BurstObservatoryObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"pingConfig\": {}\n}\n```",
            "properties": {
                "pingConfig": {
                    "$ref": "#/definitions/PingConfigObject"
                },
                "subjectSelector": {
                    "description": "一个字符串数组，其中每一个字符串将用于和出站代理标识的前缀匹配。在以下几个出站代理标识中：`[ \"a\", \"ab\", \"c\", \"ba\" ]`，`\"subjectSelector\": [\"a\"]` 将匹配到 `[ \"a\", \"ab\" ]`。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "CertificateObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"ocspStapling\": 3600,\n  \"oneTimeLoading\": false,\n  \"usage\": \"encipherment\",\n  \"buildChain\": false,\n  \"certificateFile\": \"/path/to/certificate.crt\",\n  \"keyFile\": \"/path/to/key.key\",\n  \"certificate\": [\n    \"--BEGIN CERTIFICATE--\",\n    \"MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\",\n    \"ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\",\n    \"DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\",\n    \"3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\",\n    \"OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\",\n    \"pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\",\n    \"OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\",\n    \"noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\",\n    \"A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\",\n    \"MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\",\n    \"7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\",\n    \"9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\",\n    \"6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\",\n    \"r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\",\n    \"d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\",\n    \"--END CERTIFICATE--\"\n  ],\n  \"key\": [\n    \"--BEGIN RSA PRIVATE KEY--\",\n    \"MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\",\n    \"bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\",\n    \"GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\",\n    \"jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\",\n    \"itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\",\n    \"IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\",\n    \"qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\",\n    \"C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\",\n    \"/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\",\n    \"aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\",\n    \"/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\",\n    \"bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\",\n    \"8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\",\n    \"pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\",\n    \"L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\",\n    \"3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\",\n    \"az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\",\n    \"gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\",\n    \"TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\",\n    \"eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\",\n    \"64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\",\n    \"8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\",\n    \"GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\",\n    \"ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\",\n    \"cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\",\n    \"--END RSA PRIVATE KEY--\"\n  ]\n}\n```",
            "properties": {
                "buildChain": {
                    "description": "仅当证书用途为 `issue` 时生效，若值为 `true` ，签发证书时将CA证书嵌入证书链。\n::: tip TIP 1\n不应该将根证书嵌入证书链。该选项只适合在签名CA证书为中间证书时启用。\n:::",
                    "type": "boolean"
                },
                "certificate": {
                    "description": "一个字符串数组，表示证书内容，格式如样例所示。`certificate` 和 `certificateFile` 二者选一。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "certificateFile": {
                    "description": "证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。",
                    "type": "string"
                },
                "key": {
                    "description": "一个字符串数组，表示密钥内容，格式如样例如示。`key` 和 `keyFile` 二者选一。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "keyFile": {
                    "description": "密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。",
                    "type": "string"
                },
                "ocspStapling": {
                    "description": "OCSP 装订更新，与证书热重载的时间间隔。 单位：秒。默认值为 `3600`，即一小时。",
                    "type": "number"
                },
                "oneTimeLoading": {
                    "description": "仅加载一次。值为 `true` 时将关闭证书热重载功能与 ocspStapling 功能。\n::: warning\n当值为 `true` 时，将会关闭 OCSP 装订。\n:::",
                    "type": "boolean"
                },
                "usage": {
                    "description": "证书用途，默认值为 `\"encipherment\"`。\n- `\"encipherment\"`：证书用于 TLS 认证和加密。\n- `\"verify\"`：证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。\n- `\"issue\"`：证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。\n::: tip TIP 1\n在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。\n:::\n::: tip TIP 2\n当有新的客户端请求时，假设所指定的 `serverName` 为 `\"xray.com\"`，Xray 会先从证书列表中寻找可用于 `\"xray.com\"` 的证书，如果没有找到，则使用任一 `usage`\n为 `\"issue\"` 的证书签发一个适用于 `\"xray.com\"` 的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。\n:::\n::: tip TIP 3\n当 `certificateFile` 和 `certificate` 同时指定时，Xray 优先使用 `certificateFile`。`keyFile` 和 `key` 也一样。\n:::\n::: tip TIP 4\n当 `usage` 为 `\"verify\"` 时，`keyFile` 和 `key` 可均为空。\n:::\n::: tip TIP 5\n使用 `xray tls cert` 可以生成自签名的 CA 证书。\n:::\n::: tip TIP 6\n如已经拥有一个域名, 可以使用工具便捷的获取免费第三方证书,如[acme.sh](https://github.com/acmesh-official/acme.sh)\n:::",
                    "enum": [
                        "encipherment",
                        "issue",
                        "verify"
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DnsObject": {
            "additionalProperties": {},
            "description": "`DnsObject` 对应配置文件的 `dns` 项。\n```json\n{\n  \"dns\": {\n    \"hosts\": {\n      \"baidu.com\": \"127.0.0.1\",\n      \"dns.google\": [\"8.8.8.8\", \"8.8.4.4\"]\n    },\n    \"servers\": [\n      \"8.8.8.8\",\n      \"8.8.4.4\",\n      {\n        \"address\": \"1.2.3.4\",\n        \"port\": 5353,\n        \"domains\": [\"domain:xray.com\"],\n        \"expectIPs\": [\"geoip:cn\"],\n        \"skipFallback\": false,\n        \"clientIP\": \"1.2.3.4\"\n      },\n      {\n        \"address\": \"https://8.8.8.8/dns-query\",\n        \"domains\": [\n          \"geosite:netflix\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv4\"\n      },\n      {\n        \"address\": \"https://1.1.1.1/dns-query\",\n        \"domains\": [\n          \"geosite:openai\"\n        ],\n        \"skipFallback\": true,\n        \"queryStrategy\": \"UseIPv6\"\n      },\n      \"localhost\"\n    ],\n    \"clientIp\": \"1.2.3.4\",\n    \"queryStrategy\": \"UseIP\",\n    \"disableCache\": false,\n    \"disableFallback\": false,\n    \"disableFallbackIfMatch\": false,\n    \"tag\": \"dns_inbound\"\n  }\n}\n```",
            "properties": {
                "clientIp": {
                    "description": "用于 DNS 查询时通知服务器以指定 IP 位置。不能是私有地址。\n::: tip TIP 1\n需要 DNS 服务器支持 EDNS Client Subnet。\n:::\n::: tip TIP 2\n可以在 [DnsObject](#dnsobject) 为所有 DNS 服务器指定 clientIp, 也可在每个 DNS 服务器配置的 [DnsServerObject](#dnsserverobject) 为此 DNS 服务器指定 clientIp （优先级高于 [DnsObject](#dnsobject) 的配置）。\n:::",
                    "type": "string"
                },
                "disableCache": {
                    "description": "`true` 禁用 DNS 缓存，默认为 `false`，即不禁用。",
                    "type": "boolean"
                },
                "disableFallback": {
                    "description": "`true` 禁用 DNS 的 fallback 查询，默认为 `false`，即不禁用。",
                    "type": "boolean"
                },
                "disableFallbackIfMatch": {
                    "description": "`true` 当 DNS 服务器的优先匹配域名列表命中时，禁用 fallback 查询，默认为 `false`，即不禁用。",
                    "type": "boolean"
                },
                "hosts": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Record<string,string>"
                        },
                        {
                            "$ref": "#/definitions/Record<string,string[]>"
                        }
                    ],
                    "description": "静态 IP 列表，其值为一系列的 \"域名\": \"地址\" 或 \"域名\": [\"地址 1\",\"地址 2\"]。其中地址可以是 IP 或者域名。在解析域名时，如果域名匹配这个列表中的某一项:\n- 当该项的地址为 IP 时，则解析结果为该项的 IP\n- 当该项的地址为域名时，会使用此域名进行 IP 解析，而不使用原始域名。\n- 当地址中同时设置了多个 IP 和域名，则只会返回第一个域名，其余 IP 和域名均被忽略。\n域名的格式有以下几种形式：\n- 纯字符串：当此字符串完整匹配目标域名时，该规则生效。例如 \"xray.com\" 匹配 \"xray.com\"，但不匹配 \"www.xray.com\"。\n- 正则表达式：由 `\"regexp:\"` 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com\\$\" 匹配 \"www.google.com\"、\"fonts.googleapis.com\"，但不匹配 \"google.com\"。\n- 子域名 (推荐)：由 `\"domain:\"` 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \"domain:xray.com\" 匹配 \"www.xray.com\" 与 \"xray.com\"，但不匹配 \"wxray.com\"。\n- 子串：由 `\"keyword:\"` 开始，余下部分是一个字符串。当此字符串匹配目标域名中任意部分，该规则生效。比如 \"keyword:sina.com\" 可以匹配 \"sina.com\"、\"sina.com.cn\" 和 \"www.sina.com\"，但不匹配 \"sina.cn\"。\n- 预定义域名列表：由 `\"geosite:\"` 开头，余下部分是一个名称，如 `geosite:google` 或者 `geosite:cn`。名称及域名列表参考 [预定义域名列表](./routing.md#预定义域名列表)。"
                },
                "queryStrategy": {
                    "description": "默认值 `UseIP` 同时查询 A 和 AAAA 记录。`UseIPv4` 只查询 A 记录；`UseIPv6` 只查询 AAAA 记录。\nXray-core v1.8.6 新增功能：`queryStrategy` 可以在每一项 `DNS` 服务器中分别设置。\n```json\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://8.8.8.8/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv4\" // netflix 的域名查询 A 记录\n            },\n            {\n                \"address\": \"https://1.1.1.1/dns-query\",\n                \"domains\": [\n                    \"geosite:openai\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // openai 的域名查询 AAAA 记录\n            }\n        ],\n        \"queryStrategy\": \"UseIP\" // 全局同时查询 A 和 AAAA 记录\n    }\n```\n::: tip TIP 1\n全局 `\"queryStrategy\"` 值优先，当子项中的 `\"queryStrategy\"` 值与全局 `\"queryStrategy\"` 值冲突时，子项的查询将空响应。\n:::\n::: tip TIP 2\n当子项中不写 `\"queryStrategy\"` 参数时，使用全局 `\"queryStrategy\"` 参数值。与 Xray-core v1.8.6 以前版本行为相同。\n:::\n例如：<br>\n全局 `\"queryStrategy\": \"UseIPv6\"` 与 子项 `\"queryStrategy\": \"UseIPv4\"` 冲突。<br>\n全局 `\"queryStrategy\": \"UseIPv4\"` 与 子项 `\"queryStrategy\": \"UseIPv6\"` 冲突。<br>\n全局 `\"queryStrategy\": \"UseIP\"` 与 子项 `\"queryStrategy\": \"UseIPv6\"` 不冲突。<br>\n全局 `\"queryStrategy\": \"UseIP\"` 与 子项 `\"queryStrategy\": \"UseIPv4\"` 不冲突。\n```json\n    \"dns\": {\n        \"servers\": [\n            \"https://1.1.1.1/dns-query\",\n            {\n                \"address\": \"https://8.8.8.8/dns-query\",\n                \"domains\": [\n                    \"geosite:netflix\"\n                ],\n                \"skipFallback\": true,\n                \"queryStrategy\": \"UseIPv6\" // 全局 \"UseIPv4\" 与 子项 \"UseIPv6\" 冲突\n            }\n        ],\n        \"queryStrategy\": \"UseIPv4\"\n    }\n```\n子项 netflix 的域名查询由于 `\"queryStrategy\"` 值冲突，得到空响应。netflix 的域名由 `https://1.1.1.1/dns-query` 查询，得到 A 记录。",
                    "enum": [
                        "UseIP",
                        "UseIPv4",
                        "UseIPv6"
                    ],
                    "type": "string"
                },
                "servers": {
                    "description": "一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 [DnsServerObject](#dnsserverobject) 。\n当值为 `\"localhost\"` 时，表示使用本机预设的 DNS 配置。\n当它的值是一个 DNS `\"IP:Port\"` 地址时，如 `\"8.8.8.8:53\"`，Xray 会使用此地址的指定 UDP 端口进行 DNS 查询。该查询遵循路由规则。不指定端口时，默认使用 53 端口。\n当值是 `\"tcp://host:port\"` 的形式，如 `\"tcp://8.8.8.8:53\"`，Xray 会使用 `DNS over TCP` 进行查询。该查询遵循路由规则。不指定端口时，默认使用 53 端口。\n当值是 `\"tcp+local://host:port\"` 的形式，如 `\"tcp+local://8.8.8.8:53\"`，Xray 会使用 `TCP 本地模式 (TCPL)` 进行查询。即 DNS 请求不会经过路由组件，直接通过 Freedom outbound 对外请求，以降低耗时。不指定端口时，默认使用 53 端口。\n当值是 `\"https://host:port/dns-query\"` 的形式，如 `\"https://dns.google/dns-query\"`，Xray 会使用 `DNS over HTTPS` (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 `https://1.1.1.1/dns-query`。也可使用非标准端口和路径，如 `\"https://a.b.c.d:8443/my-dns-query\"`\n当值是 `\"h2c://host:port/dns-query\"` 的形式，如 `\"h2c://dns.google/dns-query\"`，Xray 会使用  `DNS over HTTPS` 的请求格式但是将会以明文 h2c 发出请求，不能直接使用，在这种情况下需要自行配置 Freedom 出站 + streamSettings 设置 TLS 为其配置 TLS 以包装成正常的 DOH 请求。用于特殊目的，比如想要自定义 DOH 请求的 SNI 或者使用 utls 的指纹时使用\n当值是 `\"https+local://host:port/dns-query\"` 的形式，如 `\"https+local://dns.google/dns-query\"`，Xray 会使用 `DOH 本地模式 (DOHL)` 进行查询，即 DOH 请求不会经过路由组件，直接通过 Freedom outbound 对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n当值是 `\"quic+local://host\"` 的形式，如 `\"quic+local://dns.adguard.com\"`，Xray 会使用 `DNS over QUIC 本地模式 (DOQL)` 进行查询，即 DNS 请求不会经过路由组件，直接通过 Freedom outbound 对外请求。该方式需要 DNS 服务器支持 DNS over QUIC。默认使用 853 端口进行查询，可以使用非标端口。\n当值是 `fakedns` 时，将使用 FakeDNS 功能进行查询。\n::: tip TIP 1\n当使用 `localhost` 时，本机的 DNS 请求不受 Xray 控制，需要额外的配置才可以使 DNS 请求由 Xray 转发。\n:::\n::: tip TIP 2\n不同规则初始化得到的 DNS 客户端会在 Xray 启动日志中以 `info` 级别体现，比如 `local DOH`、`remote DOH` 和 `udp` 等模式。\n:::\n::: tip TIP 3\n(v1.4.0+) 可以在 [日志](./log.md) 中打开 DNS 查询日志。\n:::",
                    "items": {
                        "anyOf": [
                            {
                                "$ref": "#/definitions/DnsServerObject"
                            },
                            {
                                "type": "string"
                            }
                        ]
                    },
                    "type": "array"
                },
                "tag": {
                    "description": "由内置 DNS 发出的查询流量，除 `localhost`、`fakedns`、`TCPL`、`DOHL` 和 `DOQL` 模式外，都可以用此标识在路由使用 `inboundTag` 进行匹配。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "DnsServerObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"address\": \"1.2.3.4\",\n  \"port\": 5353,\n  \"domains\": [\"domain:xray.com\"],\n  \"expectIPs\": [\"geoip:cn\"],\n  \"skipFallback\": false,\n  \"clientIP\": \"1.2.3.4\"\n}\n```",
            "properties": {
                "address": {
                    "description": "一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 DnsServerObject 。\n当值为 `\"localhost\"` 时，表示使用本机预设的 DNS 配置。\n当它的值是一个 DNS `\"IP\"` 地址时，如 `\"8.8.8.8\"`，Xray 会使用此地址的指定 UDP 端口进行 DNS 查询。该查询遵循路由规则。默认使用 53 端口。\n当值是 `\"tcp://host\"` 的形式，如 `\"tcp://8.8.8.8\"`，Xray 会使用 `DNS over TCP` 进行查询。该查询遵循路由规则。默认使用 53 端口。\n当值是 `\"tcp+local://host\"` 的形式，如 `\"tcp+local://8.8.8.8\"`，Xray 会使用 `TCP 本地模式 (TCPL)` 进行查询。即 DNS 请求不会经过路由组件，直接通过 Freedom outbound 对外请求，以降低耗时。不指定端口时，默认使用 53 端口。\n当值是 `\"https://host:port/dns-query\"` 的形式，如 `\"https://dns.google/dns-query\"`，Xray 会使用 `DNS over HTTPS` (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 `https://1.1.1.1/dns-query`。也可使用非标准端口和路径，如 `\"https://a.b.c.d:8443/my-dns-query\"`\n当值是 `\"https+local://host:port/dns-query\"` 的形式，如 `\"https+local://dns.google/dns-query\"`，Xray 会使用 `DOH 本地模式 (DOHL)` 进行查询，即 DOH 请求不会经过路由组件，直接通过 Freedom outbound 对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n当值是 `\"quic+local://host:port\"` 的形式，如 `\"quic+local://dns.adguard.com\"`，Xray 会使用 `DOQ 本地模式 (DOQL)` 进行查询，即 DNS 请求不会经过路由组件，直接通过 Freedom outbound 对外请求。该方式需要 DNS 服务器支持 DNS over QUIC。默认使用 853 端口进行查询，可以使用非标端口。\n当值是 `fakedns` 时，将使用 FakeDNS 功能进行查询。\n::: tip 关于 local 模式和 DNS 服务器本身的域名\n由 DNS 模块发出的 DNS 请求有两种情况\nlocal 模式将直接由核心向外连接，这种情况下如果地址是一个域名将交由系统本身进行解析，逻辑较为简单\n非 local 默认将视为一个从 tag 为 dns.tag(不知道在哪？ 浏览器 ctrl+f 搜索 `inboundTag`) 的入站进来的请求，将经过正常的核心处理流程，可能会被路由模块分配去本地 freedom 或者其他远端出站，它将被 freedom 的 domainStrategy解析(注意可能的回环) 或者直接以域名的形式被传送到远端根据服务端本身的解析方式解析。\n由于普通人可能难以理清其中的逻辑，建议(特别是在透明代理的环境下)，直接在 DNS 模块的 host 选项中直接为带域名的服务器设置它们对应的 IP 防止出现回环。\n顺便 DNS 模块非 local 模式发出的 DNS 请求将会自动在路由模块中跳过 IPIfNonMatch 和 IPOnDemand 的解析过程，防止它们的解析会被送回 DNS 模块导致回环。\n:::",
                    "type": "string"
                },
                "domains": {
                    "description": "一个域名列表，此列表包含的域名，将优先使用此服务器进行查询。域名格式和 [路由配置](./routing.md#ruleobject) 中相同。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "expectIPs": {
                    "description": "一个 IP 范围列表，格式和 [路由配置](./routing.md#ruleobject) 中相同。\n当配置此项时，Xray DNS 会对返回的 IP 的进行校验，只返回包含 expectIPs 列表中的地址。\n如果未配置此项，会原样返回 IP 地址。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "port": {
                    "description": "DNS 服务器端口，如 `53`。此项缺省时默认为 `53`。当使用 DOH、DOHL、DOQL 模式时该项无效，非标端口应在 URL 中指定。",
                    "type": "number"
                },
                "skipFallback": {
                    "description": "`true`，在进行 DNS fallback 查询时将跳过此服务器, 默认为 `false`，即不跳过。",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "GRPCObject": {
            "additionalProperties": {},
            "description": "`GRPCObject` 对应传输配置的 `grpcSettings` 项。\n```json\n{\n  \"authority\": \"grpc.example.com\",\n  \"serviceName\": \"name\",\n  \"multiMode\": false,\n  \"user_agent\": \"custom user agent\",\n  \"idle_timeout\": 60,\n  \"health_check_timeout\": 20,\n  \"permit_without_stream\": false,\n  \"initial_windows_size\": 0\n}\n```",
            "properties": {
                "authority": {
                    "description": "一个字符串，可以当 Host 来用，实现一些其它用途。",
                    "type": "string"
                },
                "health_check_timeout": {
                    "description": "单位秒，健康检查的超时时间。如果在这段时间内没有完成健康检查，且仍然没有数据传输时，即认为健康检查失败。默认值为 `20`。\n::: tip\n**只需**在**出站**（**客户端**）配置。\n:::",
                    "type": "number"
                },
                "idle_timeout": {
                    "description": "单位秒，当这段时间内没有数据传输时，将会进行健康检查。如果此值设置为 `10` 以下，将会使用 `10`，即最小值。\n::: tip\n如果没有使用 Caddy 或 Nginx 等反向代理工具（**通常不会**），设为 `60` 以下，服务端可能发送意外的 h2 GOAWAY 帧以关闭现有连接。\n:::\n健康检查默认**不启用**。\n::: tip\n**只需**在**出站**（**客户端**）配置。\n:::\n::: tip\n可能会解决一些“断流”问题。\n:::",
                    "type": "number"
                },
                "initial_windows_size": {
                    "description": "h2 Stream 初始窗口大小。当值小于等于 `0` 时，此功能不生效。当值大于 `65535` 时，动态窗口机制（Dynamic Window）会被禁用。默认值为 `0`，即不生效。\n::: tip\n**只需**在**出站**（**客户端**）配置。\n:::\n::: tip\n通过 Cloudflare CDN 时，可将值设为 `65536` 及以上，即禁用动态窗口机制（Dynamic Window），可防止 Cloudflare CDN 发送意外的 h2 GOAWAY 帧以关闭现有连接。\n:::",
                    "type": "number"
                },
                "multiMode": {
                    "description": "`true` 启用 `multiMode`，默认值为： `false`。\n这是一个 **实验性** 选项，可能不会被长期保留，也不保证跨版本兼容。此模式在 **测试环境中** 能够带来约 20% 的性能提升，实际效果因传输速率不同而不同。\n::: tip\n**只需**在**出站**（**客户端**）配置。\n:::",
                    "type": "boolean"
                },
                "permit_without_stream": {
                    "description": "`true` 允许在没有子连接时进行健康检查。默认值为 `false`。\n::: tip\n**只需**在**出站**（**客户端**）配置。\n:::",
                    "type": "boolean"
                },
                "serviceName": {
                    "description": "一个字符串，指定服务名称，**类似于** HTTP/2 中的 Path。\n客户端会使用此名称进行通信，服务端会验证服务名称是否匹配。\n::: tip\n当 `serviceName` 起始为斜杠时可以自定义 path，至少要两个斜杠。<br>\n例如在服务端填写 `\"serviceName\": \"/my/sample/path1|path2\"`，客户端可填写 `\"serviceName\": \"/my/sample/path1\"` 或 `\"/my/sample/path2\"`。\n:::",
                    "type": "string"
                },
                "user_agent": {
                    "description": "::: tip\n**只需**在**出站**（**客户端**）配置。\n:::\n设置 gRPC 的用户代理，可能能防止某些 CDN 阻止 gRPC 流量。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "HTTPRequestObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"version\": \"1.1\",\n  \"method\": \"GET\",\n  \"path\": [\"/\"],\n  \"headers\": {\n    \"Host\": [\"www.baidu.com\", \"www.bing.com\"],\n    \"User-Agent\": [\n      \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\",\n      \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\"\n    ],\n    \"Accept-Encoding\": [\"gzip, deflate\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```",
            "properties": {
                "headers": {
                    "$ref": "#/definitions/Record<string,string[]>",
                    "description": "HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。"
                },
                "method": {
                    "description": "HTTP 方法，默认值为 `\"GET\"`。",
                    "type": "string"
                },
                "path": {
                    "description": "路径，一个字符串数组。默认值为 `[\"/\"]`。当有多个值时，每次请求随机选择一个值。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "version": {
                    "description": "HTTP 版本，默认值为 `\"1.1\"`。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "HTTPResponseObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"version\": \"1.1\",\n  \"status\": \"200\",\n  \"reason\": \"OK\",\n  \"headers\": {\n    \"Content-Type\": [\"application/octet-stream\", \"video/mpeg\"],\n    \"Transfer-Encoding\": [\"chunked\"],\n    \"Connection\": [\"keep-alive\"],\n    \"Pragma\": \"no-cache\"\n  }\n}\n```",
            "properties": {
                "headers": {
                    "$ref": "#/definitions/Record<string,string[]>",
                    "description": "HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。"
                },
                "reason": {
                    "description": "HTTP 状态说明，默认值为 `\"OK\"`。",
                    "type": "string"
                },
                "status": {
                    "description": "HTTP 状态，默认值为 `\"200\"`。",
                    "type": "string"
                },
                "version": {
                    "description": "HTTP 版本，默认值为 `\"1.1\"`。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "HeaderObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"type\": \"none\",\n  \"domain\": \"example.com\"\n}\n```",
            "properties": {
                "domain": {
                    "description": "配合伪装类型 `\"dns\"` 使用，可随便填一个域名。\n- [@skywind3000](https://github.com/skywind3000) 发明并实现了 KCP 协议。\n- [@xtaci](https://github.com/xtaci) 将 KCP 由 C 语言实现翻译成 Go。\n- [@xiaokangwang](https://github.com/xiaokangwang) 测试 KCP 与 Xray 的整合并提交了最初的 PR。\n原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。\n另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 \\* 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 \\* 4 = 418 字节，相当于原生的六分之一。\n原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。\nmKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。\n原生 KCP 不支持这个场景。",
                    "type": "string"
                },
                "type": {
                    "description": "伪装类型，可选的值有：\n- `\"none\"`：默认值，不进行伪装，发送的数据是没有特征的数据包。\n- `\"srtp\"`：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。\n- `\"utp\"`：伪装成 uTP 数据包，会被识别为 BT 下载数据。\n- `\"wechat-video\"`：伪装成微信视频通话的数据包。\n- `\"dtls\"`：伪装成 DTLS 1.2 数据包。\n- `\"wireguard\"`：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）\n- `\"dns\"`：某些校园网在未登录的情况下允许DNS查询，给KCP添加DNS头，把流量伪装成dns请求，可以绕过某些校园网登录。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "HttpHeaderObject": {
            "additionalProperties": {},
            "description": "HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。\n```json\n{\n  \"type\": \"http\",\n  \"request\": {},\n  \"response\": {}\n}\n```",
            "properties": {
                "request": {
                    "$ref": "#/definitions/HTTPRequestObject",
                    "description": "HTTP 请求"
                },
                "response": {
                    "$ref": "#/definitions/HTTPResponseObject",
                    "description": "HTTP 响应"
                },
                "type": {
                    "const": "http",
                    "description": "指定进行 HTTP 伪装",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "HttpUpgradeObject": {
            "additionalProperties": {},
            "description": "`HttpUpgradeObject` 对应传输配置的 `httpupgradeSettings` 项。\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  }\n}\n```",
            "properties": {
                "acceptProxyProtocol": {
                    "description": "仅用于 inbound，指示是否接收 PROXY protocol。\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) 专用于传递请求的真实来源 IP 和端口，**若你不了解它，请先忽略该项**。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 `true` 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。",
                    "type": "boolean"
                },
                "headers": {
                    "$ref": "#/definitions/Record<string,string>",
                    "description": "仅客户端，自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。"
                },
                "host": {
                    "description": "HTTPUpgrade 的HTTP请求中所发送的host，默认值为空。若服务端值为空时，不验证客户端发送来的host值。\n当在服务端指定该值，或在 ```headers``` 中指定host，将会校验与客户端请求host是否一致。\n客户端选择发送的host优先级 ```host``` >  ```headers``` > ```address```",
                    "type": "string"
                },
                "path": {
                    "description": "HTTPUpgrade 所使用的 HTTP 协议路径，默认值为 `\"/\"`。\n如果客户端路径中包含 `ed` 参数(如 ```/mypath?ed=2560```)，将会启用 `Early Data` 以降低延迟，其值为首包长度阈值。如果首包长度超过此值，就不会启用 `Early Data`。建议的值为2560。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "InboundObject": {
            "additionalProperties": {},
            "description": "`InboundObject` 对应配置文件中 `inbounds` 项的一个子元素。\n```json\n{\n  \"inbounds\": [\n    {\n      \"listen\": \"127.0.0.1\",\n      \"port\": 1080,\n      \"protocol\": \"协议名称\",\n      \"settings\": {},\n      \"streamSettings\": {},\n      \"tag\": \"标识\",\n      \"sniffing\": {\n        \"enabled\": true,\n        \"destOverride\": [\"http\", \"tls\"]\n      },\n      \"allocate\": {\n        \"strategy\": \"always\",\n        \"refresh\": 5,\n        \"concurrency\": 3\n      }\n    }\n  ]\n}\n```",
            "properties": {
                "allocate": {
                    "$ref": "#/definitions/AllocateObject",
                    "description": "当设置了多个 port 时, 端口分配的具体设置"
                },
                "listen": {
                    "description": "监听地址，IP 地址或 Unix domain socket，默认值为 `\"0.0.0.0\"`，表示接收所有网卡上的连接.\n可以指定一个系统可用的 IP 地址。\n`\"::\"` 等价于`\"0.0.0.0\"` 两者都会同时监听 IPv6 和 IPv4. 不过如果只想监听IPv6可以将 `sockopt` 的 `v6only` 设置为 true. 如果只想监听ipv4 可以用 `ip a` 等命令查看网卡上的具体 IP (通常直接就是机器的公网 IP 地址或者一个类似 10.x.x.x 的内网地址) 然后监听，当然对于 IPv6 也可以这么做。\n注意，因为UDP不是面向连接的，如果入站基于 UDP 且网卡上存在多个IP地址而外部连接的是网卡上的非首选地址，将会导致 Xray 使用错误地使用首选地址而非外部连接的目标作为源地址回复导致连接不通。\n解决办法是不要监听 `0.0.0.0` 而是监听网卡上具体的 IP 地址。\n支持填写 Unix domain socket，格式为绝对路径，形如 `\"/dev/shm/domain.socket\"`，可在开头加 `@` 代表 [abstract](https://www.man7.org/linux/man-pages/man7/unix.7.html)，`@@` 则代表带 padding 的 abstract。\n填写 Unix domain socket 时，`port` 和 `allocate` 将被忽略，协议目前可选 VLESS、VMess、Trojan，仅适用于基于 TCP 的底层传输，如 `tcp` `websocket` `grpc` 不支持基于 UDP 的传输 如 `mkcp`\n填写 Unix domain socket 时，填写为形如 `\"/dev/shm/domain.socket,0666\"` 的形式，即 socket 后加逗号及访问权限指示符，即可指定 socket 的访问权限，可用于解决默认情况下出现的 socket 访问权限问题。",
                    "type": "string"
                },
                "port": {
                    "description": "端口。接受的格式如下:\n- 整型数值：实际的端口号。\n- 环境变量：以 `\"env:\"` 开头，后面是一个环境变量的名称，如 `\"env:PORT\"`。Xray 会以字符串形式解析这个环境变量。\n- 字符串：可以是一个数值类型的字符串，如 `\"1234\"`；或者一个数值范围，如 `\"5-10\"` 表示端口 5 到端口 10，这 6 个端口。可以使用逗号进行分段，如 `11,13,15-17` 表示端口 11、端口 13、端口 15 到端口 17 这 5 个端口。\n当只有一个端口时，Xray 会在此端口监听入站连接。当指定了一个端口范围时，取决于 `allocate` 设置。",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "protocol": {
                    "description": "连接协议名称，可选的协议列表见左侧 入站代理。",
                    "enum": [
                        "dokodemo-door",
                        "http",
                        "shadowsocks",
                        "socks",
                        "trojan",
                        "vless",
                        "vmess",
                        "wireguard"
                    ],
                    "type": "string"
                },
                "settings": {
                    "description": "具体的配置内容，视协议不同而不同。详见每个协议中的 `InboundConfigurationObject`。"
                },
                "sniffing": {
                    "$ref": "#/definitions/SniffingObject",
                    "description": "流量探测主要作用于在透明代理等用途.\n比如一个典型流程如下:\n1. 如有一个设备上网,去访问 abc.com,首先设备通过 DNS 查询得到 abc.com 的 IP 是 1.2.3.4,然后设备会向 1.2.3.4 去发起连接.\n2. 如果不设置嗅探,Xray 收到的连接请求是 1.2.3.4,并不能用于域名规则的路由分流.\n3. 当设置了 sniffing 中的 enable 为 true,Xray 处理此连接的流量时,会从流量的数据中,嗅探出域名,即 abc.com\n4. Xray 会把 1.2.3.4 重置为 abc.com.路由就可以根据域名去进行路由的域名规则的分流\n因为变成了一个向 abc.com 请求的连接, 就可以做更多的事情, 除了路由域名规则分流, 还能重新做 DNS 解析等其他工作.\n当设置了 sniffing 中的 enable 为 true, 还能嗅探出 bittorrent 类型的流量, 然后可以在路由中配置\"protocol\"项来设置规则处理 BT 流量, 比如服务端用来拦截 BT 流量, 或客户端固定转发 BT 流量到某个 VPS 去等."
                },
                "streamSettings": {
                    "$ref": "#/definitions/StreamSettingsObject",
                    "description": "底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式"
                },
                "tag": {
                    "description": "::: danger\n当其不为空时，其值必须在所有 `tag` 中**唯一**。\n:::",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "KcpObject": {
            "additionalProperties": {},
            "description": "`KcpObject` 对应传输配置的 `kcpSettings` 项。\n```json\n{\n  \"mtu\": 1350,\n  \"tti\": 20,\n  \"uplinkCapacity\": 5,\n  \"downlinkCapacity\": 20,\n  \"congestion\": false,\n  \"readBufferSize\": 1,\n  \"writeBufferSize\": 1,\n  \"header\": {\n    \"type\": \"none\",\n    \"domain\": \"example.com\"\n  },\n  \"seed\": \"Password\"\n}\n```",
            "properties": {
                "congestion": {
                    "description": "是否启用拥塞控制。\n开启拥塞控制之后，Xray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。\n默认值为 `false`",
                    "type": "boolean"
                },
                "downlinkCapacity": {
                    "description": "下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 `20`。\n::: tip\n`uplinkCapacity` 和 `downlinkCapacity` 决定了 mKCP 的传输速度。\n以客户端发送数据为例，客户端的 `uplinkCapacity` 指定了发送数据的速度，而服务器端的 `downlinkCapacity` 指定了接收数据的速度。两者的值以较小的一个为准。\n推荐把 `downlinkCapacity` 设置为一个较大的值，比如 100，而 `uplinkCapacity` 设为实际的网络速度。当速度不够时，可以逐渐增加 `uplinkCapacity` 的值，直到带宽的两倍左右。\n:::",
                    "type": "number"
                },
                "header": {
                    "$ref": "#/definitions/HeaderObject",
                    "description": "数据包头部伪装设置"
                },
                "mtu": {
                    "description": "最大传输单元（maximum transmission unit）\n请选择一个介于 576 - 1460 之间的值。\n默认值为 `1350`。",
                    "type": "number"
                },
                "readBufferSize": {
                    "description": "单个连接的读取缓冲区大小，单位是 MB。\n默认值为 `2`。",
                    "type": "number"
                },
                "seed": {
                    "description": "可选的混淆密码，使用 AES-128-GCM 算法混淆流量数据，客户端和服务端需要保持一致。\n本混淆机制不能用于保证通信内容的安全，但可能可以对抗部分封锁。",
                    "type": "string"
                },
                "tti": {
                    "description": "传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。\n请选译一个介于 10 - 100 之间的值。\n默认值为 `50`。",
                    "type": "number"
                },
                "uplinkCapacity": {
                    "description": "上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 `5`。",
                    "type": "number"
                },
                "writeBufferSize": {
                    "description": "单个连接的写入缓冲区大小，单位是 MB。\n默认值为 `2`。\n::: tip\n`readBufferSize` 和 `writeBufferSize` 指定了单个连接所使用的内存大小。\n在需要高速传输时，指定较大的 `readBufferSize` 和 `writeBufferSize` 会在一定程度上提高速度，但也会使用更多的内存。\n在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 `readBufferSize` 和 `writeBufferSize` 的值，然后手动平衡速度和内存的关系。\n:::",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "LogObject": {
            "additionalProperties": {},
            "description": "LogObject 对应配置文件的 `log` 项。\n```json\n{\n  \"log\": {\n    \"access\": \"文件地址\",\n    \"error\": \"文件地址\",\n    \"loglevel\": \"warning\",\n    \"dnsLog\": false,\n    \"maskAddress\": \"\"\n  }\n}\n```",
            "properties": {
                "access": {
                    "description": "访问日志的文件地址，其值是一个合法的文件地址，如`\"/var/log/Xray/access.log\"`（Linux）或者`\"C:\\\\Temp\\\\Xray\\\\_access.log\"`（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n- 特殊值`none`，即关闭 access log。",
                    "type": "string"
                },
                "dnsLog": {
                    "description": "是否启用 DNS 查询日志，例如：`DOH//doh.server got answer: domain.com -> [ip1, ip2] 2.333ms`",
                    "type": "boolean"
                },
                "error": {
                    "description": "错误日志的文件地址，其值是一个合法的文件地址，如`\"/var/log/Xray/error.log\"`（Linux）或者`\"C:\\\\Temp\\\\Xray\\\\_error.log\"`（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n- 特殊值`none`，即关闭 error log。",
                    "type": "string"
                },
                "loglevel": {
                    "description": "error 日志的级别, 指示 error 日志需要记录的信息.\n默认值为 `\"warning\"`。\n- `\"debug\"`：调试程序时用到的输出信息。同时包含所有 `\"info\"` 内容。\n- `\"info\"`：运行时的状态信息等，不影响正常使用。同时包含所有 `\"warning\"` 内容。\n- `\"warning\"`：发生了一些并不影响正常运行的问题时输出的信息，但有可能影响用户的体验。同时包含所有 `\"error\"` 内容。\n- `\"error\"`：Xray 遇到了无法正常运行的问题，需要立即解决。\n- `\"none\"`：不记录任何内容。",
                    "enum": [
                        "debug",
                        "error",
                        "info",
                        "none",
                        "warning"
                    ],
                    "type": "string"
                },
                "maskAddress": {
                    "description": "IP地址遮罩，启用后将自动替换log中出现的IP地址，用于在分享日志时保护隐私，默认为空即不启用。\n目前可选等级 `quarter` `half` `full` 遮罩形式对应如下\n- ipv4 `1.2.*.*` `1.*.*.*` `[Masked IPv4]`\n- ipv6 `1234:5678::/32` `1234::/16` `[Masked IPv6]`",
                    "enum": [
                        "full",
                        "half",
                        "quarter"
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MuxObject": {
            "additionalProperties": {},
            "description": "Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见 [Mux.Cool](../../development/protocols/muxcool)。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。Mux 的第二个用途是分发多个 UDP 连接，即 XUDP。\n`MuxObject` 对应 `OutboundObject` 中的 `mux` 项。\n```json\n{\n  \"enabled\": true,\n  \"concurrency\": 8,\n  \"xudpConcurrency\": 16,\n  \"xudpProxyUDP443\": \"reject\"\n}\n```",
            "properties": {
                "concurrency": {
                    "description": "最大并发连接数。最小值 `1`，最大值 `128`。省略或者填 `0` 时都等于 `8`, 大于`128` 的值都将视为128.\n这个数值表示了一个 TCP 连接上最多承载的子连接数量。比如设置 `concurrency=8` 时，当客户端发出了 8 个 TCP 请求，Xray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。\n核心并不会回收关闭子连接id, 这意味着这其实是一个连接最大可以被复用的次数，比方说如果设置为 16, 如果该连接已经被复用了 16 次，其中 10 条已经关闭了，这并不会为该连接“腾出”十个位置，核心仍会认为该连接复用次数已满并打开新的连接\n::: tip\n填负数时，如 `-1`，不使用 Mux 模块承载 TCP 流量。\n:::",
                    "type": "number"
                },
                "enabled": {
                    "description": "是否启用 Mux 转发请求，默认值 `false`。",
                    "type": "boolean"
                },
                "xudpConcurrency": {
                    "description": "使用新 XUDP 聚合隧道（也就是另一条 Mux 连接）代理 UDP 流量，填写最大并发子 UoT 数量。最小值 `1`，最大值 `1024`。\n省略或者填 `0` 时，将与 TCP 流量走同一条路，也就是传统的行为。\n::: tip\n填负数时，如 `-1`，不使用 Mux 模块承载 UDP 流量。将使用代理协议原本的 UDP 传输方式。例如 `Shadowsocks` 会使用原生 UDP，`VLESS` 会使用 UoT。\n:::",
                    "type": "number"
                },
                "xudpProxyUDP443": {
                    "description": "控制 Mux 对于被代理的 UDP/443（QUIC）流量的处理方式：\n- 默认 `reject` 拒绝流量（一般浏览器会自动回落到 TCP HTTP2）\n- `allow` 允许走 Mux 连接。\n- 填 `skip` 时，不使用 Mux 模块承载 UDP 443 流量。将使用代理协议原本的 UDP 传输方式。例如 `Shadowsocks` 会使用原生 UDP，`VLESS` 会使用 UoT。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "NoneHeaderObject": {
            "additionalProperties": {},
            "description": "不进行伪装\n```json\n{\n  \"type\": \"none\"\n}\n```",
            "properties": {
                "type": {
                    "const": "none",
                    "description": "指定不进行伪装",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ObservatoryObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"subjectSelector\":[\n    \"outbound\"\n  ],\n  \"probeUrl\": \"https://www.google.com/generate_204\",\n  \"probeInterval\": \"10s\",\n  \"enableConcurrency\": false\n}\n```",
            "properties": {
                "enableConcurrency": {
                    "description": "- `true` 并发探测全部匹配的出站代理，全部完成后暂停 `probeInterval` 设定的时间。\n- `false` 逐个探测匹配的出站代理，每探测一个出站代理后暂停 `probeInterval` 设定的时间。",
                    "type": "boolean"
                },
                "probeInterval": {
                    "description": "发起探测的间隔。时间格式为数字 + 单位，比如 `\"10s\"`, `\"2h45m\"`，支持的时间单位有 `ns`, `us`, `ms`, `s`, `m`, `h`， 分别对应纳秒、微秒、毫秒、秒、分、时。",
                    "type": "string"
                },
                "probeUrl": {
                    "description": "用于探测出站代理连接状态的网址。",
                    "type": "string"
                },
                "subjectSelector": {
                    "description": "一个字符串数组，其中每一个字符串将用于和出站代理标识的前缀匹配。在以下几个出站代理标识中：`[ \"a\", \"ab\", \"c\", \"ba\" ]`，`\"subjectSelector\": [\"a\"]` 将匹配到 `[ \"a\", \"ab\" ]`。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "OutboundObject": {
            "additionalProperties": {},
            "description": "`OutboundObject` 对应配置文件中 `outbounds` 项的一个子元素。\n::: tip\n列表中的第一个元素作为主 outbound。当路由匹配不存在或没有匹配成功时，流量由主 outbound 发出。\n:::\n```json\n{\n  \"outbounds\": [\n    {\n      \"sendThrough\": \"0.0.0.0\",\n      \"protocol\": \"协议名称\",\n      \"settings\": {},\n      \"tag\": \"标识\",\n      \"streamSettings\": {},\n      \"proxySettings\": {\n        \"tag\": \"another-outbound-tag\"\n      },\n      \"mux\": {}\n    }\n  ]\n}\n```",
            "properties": {
                "mux": {
                    "$ref": "#/definitions/MuxObject",
                    "description": "Mux 相关的具体配置。"
                },
                "protocol": {
                    "description": "连接协议名称，可选的协议列表见左侧 出站代理。",
                    "type": "string"
                },
                "proxySettings": {
                    "$ref": "#/definitions/ProxySettingsObject",
                    "description": "出站代理配置。当出站代理生效时，此 outbound 的 `streamSettings` 将不起作用。"
                },
                "sendThrough": {
                    "description": "用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为 `\"0.0.0.0\"`。\n允许在其中填入 IPv6 CIDR 块(如114:514:1919:810::/64)，Xray将会使用地址块中随机的IP地址对外发起连接。\n需要正确配置网络接入方式，路由表以及内核参数以允许 Xray bind 至地址块内的任意IP。\n对于使用ndp接入的网络，不建议设置小于 /120 的子网，否则可能会造成 NDP flood 导致路由器邻居缓存被占满等一系列问题。\n特殊值 `origin` 若使用该值，将使用本机被连接的IP发出请求。\n例如机器上存在一整段 IPv4 `11.4.5.0/24` 且监听 0.0.0.0(网卡上的全部IPv4与IPv6)，若客户端通过 `11.4.5.14` 连接到本机，那么出站也会通过 `11.4.5.14` 发送对外请求；如果使用 `11.4.5.10` 连接到本机，那么出站就会通过 `11.4.5.10` 发送请求。 同样适用于机器上有整段/复数个 IPv6 的情况",
                    "type": "string"
                },
                "settings": {
                    "description": "具体的配置内容，视协议不同而不同。详见每个协议中的 `OutboundConfigurationObject`。"
                },
                "streamSettings": {
                    "$ref": "#/definitions/StreamSettingsObject",
                    "description": "底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式"
                },
                "tag": {
                    "description": "此出站连接的标识，用于在其它的配置中定位此连接。\n::: danger\n当其不为空时，其值必须在所有 `tag` 中 **唯一**。\n:::",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "PingConfigObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"destination\": \"https://connectivitycheck.gstatic.com/generate_204\",\n  \"connectivity\": \"\",\n  \"interval\": \"1h\",\n  \"sampling\": 3,\n  \"timeout\": \"30s\"\n}\n```",
            "properties": {
                "connectivity": {
                    "description": "用于检测本地网络连通性的网址。空字符串表示不检测本地网络连通性。",
                    "type": "string"
                },
                "destination": {
                    "description": "用于探测出站代理连接状态的网址。这个网址应该返回 HTTP 204 成功状态码。",
                    "type": "string"
                },
                "interval": {
                    "description": "在指定时间内探测全部匹配的出站代理，每个出站代理探测 sampling + 1 次。时间格式为数字 + 单位，比如 `\"10s\"`, `\"2h45m\"`，支持的时间单位有 `ns`, `us`, `ms`, `s`, `m`, `h`， 分别对应纳秒、微秒、毫秒、秒、分、时。",
                    "type": "string"
                },
                "sampling": {
                    "description": "保留最近探测结果的数量。",
                    "type": "number"
                },
                "timeout": {
                    "description": "探测超时时间。格式和上面的 `interval` 相同。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "PolicyObject": {
            "additionalProperties": {},
            "description": "`PolicyObject` 对应配置文件的 `policy` 项。\n```json\n{\n  \"policy\": {\n    \"levels\": {\n      \"0\": {\n        \"handshake\": 4,\n        \"connIdle\": 300,\n        \"uplinkOnly\": 2,\n        \"downlinkOnly\": 5,\n        \"statsUserUplink\": false,\n        \"statsUserDownlink\": false,\n        \"statsUserOnline\": false,\n        \"bufferSize\": 4\n      }\n    },\n    \"system\": {\n      \"statsInboundUplink\": false,\n      \"statsInboundDownlink\": false,\n      \"statsOutboundUplink\": false,\n      \"statsOutboundDownlink\": false\n    }\n  }\n}\n```",
            "properties": {
                "level": {
                    "$ref": "#/definitions/Record<string,LevelPolicyObject>",
                    "description": "一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 `\"0\"`、`\"1\"` 等，双引号不能省略，此数字对应用户等级。每一个值是一个 [LevelPolicyObject](#levelpolicyobject).\n::: tip\n每个入站出站代理现在都可以设置用户等级，Xray 会根据实际的用户等级应用不同的本地策略。\n:::"
                },
                "system": {
                    "$ref": "#/definitions/SystemPolicyObject",
                    "description": "Xray 系统级别的策略"
                }
            },
            "type": "object"
        },
        "PortalObject": {
            "additionalProperties": {},
            "description": "```jsonc\n{\n  \"tag\": \"portal\",\n  \"domain\": \"reverse-proxy.xray.internal\"\n}\n```",
            "properties": {
                "domain": {
                    "description": "一个域名。当 `portal` 接收到流量时，如果流量的目标域名是此域名，则 `portal` 认为当前连接上是 `bridge` 发来的通信连接。而其它流量则会被当成需要转发的流量。`portal` 所做的工作就是把这两类连接进行识别并做对应的转发。\n::: tip\n一个 Xray 既可以作为 `bridge`，也可以作为 `portal`，也可以同时两者，以适用于不同的场景需要。\n:::\n::: tip\n在运行过程中，建议先启用 `bridge`，再启用 `portal`。\n:::\n`bridge` 通常需要两个 outbound，一个用于连接 `portal`，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。\n反向代理配置:\n```jsonc\n\"reverse\": {\n  \"bridges\": [\n    {\n      \"tag\": \"bridge\",\n      \"domain\": \"reverse-proxy.xray.internal\"\n    }\n  ]\n}\n```\noutbound:\n```jsonc\n{\n  // 转发到网页服务器\n  \"tag\": \"out\",\n  \"protocol\": \"freedom\",\n  \"settings\": {\n    \"redirect\": \"127.0.0.1:80\"\n  }\n}\n```\n```jsonc\n{\n  // 连接到 portal\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"vnext\": [\n      {\n        \"address\": \"portal 的 IP 地址\",\n        \"port\": 1024,\n        \"users\": [\n          {\n            \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n          }\n        ]\n      }\n    ]\n  },\n  \"tag\": \"interconn\"\n}\n```\n路由配置:\n```jsonc\n{\n  \"rules\": [\n    {\n      // bridge 发出的请求，且域名为配置的域名，那么说明这是尝试向 portal 建立反向隧道的请求，\n      // 则路由到 interconn，即连接到 portal\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"domain\": [\"full:reverse-proxy.xray.internal\"],\n      \"outboundTag\": \"interconn\"\n    },\n    {\n      // 从 portal 过来的流量，也会从 bridge 出来，但是不带上面的domain\n      // 则路由到 out，即转发给网页服务器\n      \"type\": \"field\",\n      \"inboundTag\": [\"bridge\"],\n      \"outboundTag\": \"out\"\n    }\n  ]\n}\n```\n`portal` 通常需要两个 inbound，一个用于接收 `bridge` 的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。\n反向代理配置:\n```jsonc\n\"reverse\": {\n  \"portals\": [\n    {\n      \"tag\": \"portal\",\n      \"domain\": \"reverse-proxy.xray.internal\" // 必须和 bridge 的配置一样\n    }\n  ]\n}\n```\ninbound:\n```jsonc\n{\n  // 直接接收来自公网的请求\n  \"tag\": \"external\",\n  \"port\": 80,\n  \"protocol\": \"dokodemo-door\",\n  \"settings\": {\n    \"address\": \"127.0.0.1\",\n    \"port\": 80,\n    \"network\": \"tcp\"\n  }\n}\n```\n```jsonc\n{\n  // 接收来自 bridge 尝试建立反向隧道的请求\n  \"tag\": \"interconn\",\n  \"port\": 1024,\n  \"protocol\": \"vmess\",\n  \"settings\": {\n    \"clients\": [\n      {\n        \"id\": \"5783a3e7-e373-51cd-8642-c83782b807c5\"\n      }\n    ]\n  }\n}\n```\n路由配置:\n```jsonc\n{\n  \"rules\": [\n    {\n      // 如果入站是 external，说明是来自公网的请求，\n      // 则路由到 portal, 最终会转发给 bridge\n      \"type\": \"field\",\n      \"inboundTag\": [\"external\"],\n      \"outboundTag\": \"portal\"\n    },\n    {\n      // 如果来自 interconn 入站，说明是来自 bridge 的尝试建立反向隧道请求，\n      // 则路由到 portal, 最终会转发给对应的公网客户端\n      // 注意：这里进入的请求会带上了前文配置的domain，所以 portal 能够区分两种被路由到 portal 的请求\n      \"type\": \"field\",\n      \"inboundTag\": [\"interconn\"],\n      \"outboundTag\": \"portal\"\n    }\n  ]\n}\n```",
                    "type": "string"
                },
                "tag": {
                    "description": "`portal` 的标识。在 [路由配置](./routing.md) 中使用 `outboundTag` 将流量转发到这个 `portal`。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ProxySettingsObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"tag\": \"another-outbound-tag\"\n}\n```",
            "properties": {
                "tag": {
                    "description": "当指定另一个 outbound 的标识时，此 outbound 发出的数据，将被转发至所指定的 outbound 发出。\n::: danger\n这种转发方式**不经过**底层传输方式。如果需要使用支持底层传输方式的转发，请使用 [SockOpt.dialerProxy](./transport.md#sockoptobject)。\n:::\n::: danger\n此选项与 SockOpt.dialerProxy 不兼容\n:::\n::: tip\n兼容 v2fly/v2ray-core 的配置 [transportLayer](https://www.v2fly.org/config/outbounds.html#proxysettingsobject)\n:::",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "RawObject": {
            "additionalProperties": {},
            "description": "`RawObject` 对应传输配置的 `rawSettings` 项。\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"header\": {\n    \"type\": \"none\"\n  }\n}\n```",
            "properties": {
                "acceptProxyProtocol": {
                    "description": "仅用于 inbound，指示是否接收 PROXY protocol。\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) 专用于传递请求的真实来源 IP 和端口，**若你不了解它，请先忽略该项**。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 `true` 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\n默认值为 `false`。",
                    "type": "boolean"
                },
                "header": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/NoneHeaderObject"
                        },
                        {
                            "$ref": "#/definitions/HttpHeaderObject"
                        }
                    ],
                    "description": "数据包头部伪装设置，默认值为 `NoneHeaderObject`。\n::: tip\nHTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。\n:::"
                }
            },
            "type": "object"
        },
        "RealityObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"show\": false,\n  \"target\": \"example.com:443\",\n  \"xver\": 0,\n  \"serverNames\": [\"example.com\", \"www.example.com\"],\n  \"privateKey\": \"\",\n  \"minClientVer\": \"\",\n  \"maxClientVer\": \"\",\n  \"maxTimeDiff\": 0,\n  \"shortIds\": [\"\", \"0123456789abcdef\"],\n  \"fingerprint\": \"chrome\",\n  \"serverName\": \"\",\n  \"publicKey\": \"\",\n  \"shortId\": \"\",\n  \"spiderX\": \"\"\n}\n```\n::: tip\n更多信息请参考 [REALITY 项目](https://github.com/XTLS/REALITY).\n:::\n::: tip\nReality 只是修改了TLS，客户端的实现只需要轻度修改完全随机的 session id 和自定义证书验证即可，理论上与大多数 TLS 组合完全兼容。\n但这并不适用于 QUIC, 因为 Reality 需要修改的 session id 字段在几乎所有 TCP TLS 的实现上出于兼容目的全部是随机数，但是在 QUIC TLS 上该字段为 0 长度，没有修改的空间。\n:::",
            "properties": {
                "fingerprint": {
                    "description": "必填，同 [TLSObject](#tlsobject)。",
                    "type": "string"
                },
                "maxClientVer": {
                    "description": "选填，客户端 Xray 最高版本，格式为 `x.y.z`。",
                    "type": "string"
                },
                "maxTimeDiff": {
                    "description": "选填，允许的最大时间差，单位为毫秒。",
                    "type": "number"
                },
                "minClientVer": {
                    "description": "选填，客户端 Xray 最低版本，格式为 `x.y.z`。",
                    "type": "string"
                },
                "privateKey": {
                    "description": "必填，执行 `./xray x25519` 生成。",
                    "type": "string"
                },
                "publicKey": {
                    "description": "必填，服务端私钥对应的公钥。使用 `./xray x25519 -i \"服务器私钥\"` 生成。",
                    "type": "string"
                },
                "serverName": {
                    "description": "服务端 serverNames 之一。\n当服务端 ```serverNames``` 中包含空值时，与 TLS 类似可以在客户端使用 ```\"serverName\": \"0.0.0.0\"``` 发起无SNI的连接。与TLS不同，REALITY使用这个功能并不需要开启也没有允许不安全选项。当使用此功能时请确保target在接受无SNI的连接时会返回默认证书。",
                    "type": "string"
                },
                "serverNames": {
                    "description": "必填，客户端可用的 `serverName` 列表，暂不支持 \\* 通配符。\n一般与target保持一致即可，实际的可选值为服务器所接受的任何SNI（依据 target 本身的配置有所不同），一个参考是所返回证书的 [SAN](https://zh.wikipedia.org/wiki/%E4%B8%BB%E9%A2%98%E5%A4%87%E7%94%A8%E5%90%8D%E7%A7%B0).\n其中可包含空值 ```\"\"``` 代表接受没有SNI的连接。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "shortId": {
                    "description": "服务端 shortIds 之一。\n长度为 8 个字节，即 16 个 0~f 的数字字母，可以小于16个，核心将会自动在后面补0, 但位数必须是**偶数** (因为一个字节有2位16进制数)\n如 `aa1234` 会被自动补全为 `aa12340000000000`, 但是`aaa1234` 则会导致错误。\n0也是偶数，所以若服务端的 `shordIDs` 包含空值 `\"\"` ，客户端也可为空。",
                    "type": "string"
                },
                "shortIds": {
                    "description": "必填，客户端可用的 `shortId` 列表，可用于区分不同的客户端。\n格式要求见 `shortId`\n若包含空值，客户端 `shortId` 可为空。\n::: tip\n以下为**出站**（**客户端**）配置。\n:::",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "show": {
                    "description": "当值为 `true` 时，输出调试信息。\n::: tip\n以下为**入站**（**服务端**）配置。\n:::",
                    "type": "boolean"
                },
                "spiderX": {
                    "description": "爬虫初始路径与参数，建议每个客户端不同。",
                    "type": "string"
                },
                "target": {
                    "description": "必填，格式同 VLESS `fallbacks` 的 [dest](./features/fallback.md#fallbackobject)。\n旧称 dest, 当前版本两个字段互为alias\n::: warning\n为了伪装的效果考虑，Xray对于鉴权失败（非合法reality请求）的流量，会**直接转发**至 target.\n如果 target 网站的 IP 地址特殊（如使用了 CloudFlare CDN 的网站） 则相当于你的服务器充当了 CloudFlare 的端口转发，可能造成被扫描后偷跑流量的情况。\n为了杜绝这种情况，可以考虑前置Nginx等方法过滤掉不符合要求的SNI。\n:::",
                    "type": "string"
                },
                "xver": {
                    "description": "选填，格式同 VLESS `fallbacks` 的 [xver](./features/fallback.md#fallbackobject)",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "Record<string,LevelPolicyObject>": {
            "type": "object"
        },
        "Record<string,string>": {
            "type": "object"
        },
        "Record<string,string[]>": {
            "type": "object"
        },
        "ReverseObject": {
            "additionalProperties": {},
            "description": "`ReverseObject` 对应配置文件的 `reverse` 项。\n```jsonc\n{\n  \"reverse\": {\n    \"bridges\": [\n      {\n        \"tag\": \"bridge\",\n        \"domain\": \"reverse-proxy.xray.internal\"\n      }\n    ],\n    \"portals\": [\n      {\n        \"tag\": \"portal\",\n        \"domain\": \"reverse-proxy.xray.internal\"\n      }\n    ]\n  }\n}\n```",
            "properties": {
                "bridges": {
                    "description": "数组，每一项表示一个 `bridge`。每个 `bridge` 的配置是一个 [BridgeObject](#bridgeobject)。",
                    "items": {
                        "$ref": "#/definitions/BridgeObject"
                    },
                    "type": "array"
                },
                "portals": {
                    "description": "数组，每一项表示一个 `portal`。每个 `portal` 的配置是一个 [PortalObject](#bridgeobject)。",
                    "items": {
                        "$ref": "#/definitions/PortalObject"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "RoutingObject": {
            "additionalProperties": {},
            "description": "`RoutingObject` 对应配置文件的 `routing` 项。\n```json\n{\n  \"routing\": {\n    \"domainStrategy\": \"AsIs\",\n    \"domainMatcher\": \"hybrid\",\n    \"rules\": [],\n    \"balancers\": []\n  }\n}\n```",
            "properties": {
                "balancers": {
                    "description": "一个数组，数组中每一项是一个负载均衡器的配置。\n当一个规则指向一个负载均衡器时，Xray 会通过此负载均衡器选出一个 outbound, 然后由它转发流量。",
                    "items": {
                        "$ref": "#/definitions/BalancerObject"
                    },
                    "type": "array"
                },
                "domainMatcher": {
                    "description": "域名匹配算法，根据不同的设置使用不同的算法。此处选项会影响所有未单独指定匹配算法的 `RuleObject`。\n- `\"hybrid\"`：使用新的域名匹配算法，速度更快且占用更少。默认值。\n- `\"linear\"`：使用原来的域名匹配算法。",
                    "enum": [
                        "hybrid",
                        "linear"
                    ],
                    "type": "string"
                },
                "domainStrategy": {
                    "description": "域名解析策略，根据不同的设置使用不同的策略。\n- `\"AsIs\"`：只使用域名进行路由选择。默认值。\n- `\"IPIfNonMatch\"`：当域名没有匹配任何规则时，将域名解析成 IP（A 记录或 AAAA 记录）再次进行匹配；\n  - 当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止；\n  - 解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；\n- `\"IPOnDemand\"`：当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；",
                    "enum": [
                        "AsIs",
                        "IPIfNonMatch",
                        "IPOnDemand"
                    ],
                    "type": "string"
                },
                "rules": {
                    "description": "对应一个数组，数组中每一项是一个规则。\n对于每一个连接，路由将根据这些规则从上到下依次进行判断，当遇到第一个生效规则时，即将这个连接转发至它所指定的 `outboundTag`或 `balancerTag`。\n::: tip\n当没有匹配到任何规则时，流量默认由第一个 outbound 发出。\n:::",
                    "items": {
                        "$ref": "#/definitions/RuleObject"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "RuleObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"domainMatcher\": \"hybrid\",\n  \"type\": \"field\",\n  \"domain\": [\"baidu.com\", \"qq.com\", \"geosite:cn\"],\n  \"ip\": [\"0.0.0.0/8\", \"10.0.0.0/8\", \"fc00::/7\", \"fe80::/10\", \"geoip:cn\"],\n  \"port\": \"53,443,1000-2000\",\n  \"sourcePort\": \"53,443,1000-2000\",\n  \"network\": \"tcp\",\n  \"source\": [\"10.0.0.1\"],\n  \"user\": [\"love@xray.com\"],\n  \"inboundTag\": [\"tag-vmess\"],\n  \"protocol\": [\"http\", \"tls\", \"quic\", \"bittorrent\"],\n  \"attrs\": { \":method\": \"GET\" },\n  \"outboundTag\": \"direct\",\n  \"balancerTag\": \"balancer\",\n  \"ruleTag\": \"rule name\"\n}\n```\n::: danger\n当多个属性同时指定时，这些属性需要**同时**满足，才可以使当前规则生效。\n:::",
            "properties": {
                "attrs": {
                    "additionalProperties": true,
                    "description": "一个 json object，键名字和值皆为字符串，用于检测 HTTP 流量的属性值(由于显而易见的原因，只支持 1.0 和 1.1)。当 HTTP headers 包含所有指定的键，并且值包含指定的子字符串，则命中此规则。键大小写不敏感。值支持使用正则表达式。\n同时也支持类似 h2 的伪头部 `:method` 和 `:path` 用于匹配方法和路径(尽管在 HTTP/1.1 中是不存在这些 header 的)\n对于 HTTP 入站的非 CONNECT 方法，可以直接获取到attrs, 对于其他入站则需要开启 sniffing 嗅探才能获得这些值用于匹配。\n示例：\n- 检测 HTTP GET：`{\":method\": \"GET\"}`\n- 检测 HTTP Path：`{\":path\": \"/test\"}`\n- 检测 Content Type：`{\"accept\": \"text/html\"}`",
                    "properties": {},
                    "type": "object"
                },
                "balancerTag": {
                    "description": "对应一个 Balancer 的标识。\n::: tip\n`balancerTag` 和 `outboundTag` 须二选一。当同时指定时，`outboundTag` 生效。\n:::",
                    "type": "string"
                },
                "domain": {
                    "description": "一个数组，数组每一项是一个域名的匹配。有以下几种形式：\n- 纯字符串：当此字符串匹配目标域名中任意部分，该规则生效。比如 \"sina.com\" 可以匹配 \"sina.com\"、\"sina.com.cn\" 和 \"www.sina.com\"，但不匹配 \"sina.cn\"。\n- 正则表达式：由 `\"regexp:\"` 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 `\"regexp:\\\\\\\\.goo.\\*\\\\\\\\.com\\$\"` 匹配 \"www.google.com\" 或 \"fonts.googleapis.com\"，但不匹配 \"google.com\"。（注意，在 json 中，经常在正则表达式中使用的反斜杠会被用作转义，当正则表达式中的反斜杠 `\\` 应改为 `\\\\`）\n- 子域名（推荐）：由 `\"domain:\"` 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \"domain:xray.com\" 匹配 \"www.xray.com\"、\"xray.com\"，但不匹配 \"wxray.com\"。\n- 完整匹配：由 `\"full:\"` 开始，余下部分是一个域名。当此域名完整匹配目标域名时，该规则生效。例如 \"full:xray.com\" 匹配 \"xray.com\" 但不匹配 \"www.xray.com\"。\n- 预定义域名列表：由 `\"geosite:\"` 开头，余下部分是一个名称，如 `geosite:google` 或者 `geosite:cn`。名称及域名列表参考 [预定义域名列表](#预定义域名列表)。\n- 从文件中加载域名：形如 `\"ext:file:tag\"`，必须以 `ext:`（小写）开头，后面跟文件名和标签，文件存放在 [资源目录](./features/env.md#资源文件路径) 中，文件格式与 `geosite.dat` 相同，标签必须在文件中存在。\n::: tip\n`\"ext:geoip.dat:cn\"` 等价于 `\"geoip:cn\"`\n:::",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "domainMatcher": {
                    "description": "域名匹配算法，根据不同的设置使用不同的算法。此处选项优先级高于 `RoutingObject` 中配置的 `domainMatcher`。\n- `\"hybrid\"`：使用新的域名匹配算法，速度更快且占用更少。默认值。\n- `\"linear\"`：使用原来的域名匹配算法。",
                    "enum": [
                        "hybrid",
                        "linear"
                    ],
                    "type": "string"
                },
                "inboundTag": {
                    "description": "一个数组，数组内每一项是一个标识。当某一项匹配入站协议的标识时，此规则生效。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "ip": {
                    "description": "一个数组，数组内每一项代表一个 IP 范围。当某一项匹配目标 IP 时，此规则生效。有以下几种形式：\n- IP：形如 `\"127.0.0.1\"`。\n- [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)：形如 `\"10.0.0.0/8\"`，也可以用 `\"0.0.0.0/0\"` `\"::/0\"` 来指定所有 IPv4 或者 IPv6.\n- 预定义 IP 列表：此列表预置于每一个 Xray 的安装包中，文件名为 `geoip.dat`。使用方式形如 `\"geoip:cn\"`，必须以 `geoip:`（小写）开头，后面跟双字符国家代码，支持几乎所有可以上网的国家。\n  - 特殊值：`\"geoip:private\"`，包含所有私有地址，如 `127.0.0.1`。\n  - 反选（!）功能，`\"geoip:!cn\"` 表示非 geoip:cn 中的结果。\n- 从文件中加载 IP：形如 `\"ext:file:tag\"`，必须以 `ext:`（小写）开头，后面跟文件名和标签，文件存放在 [资源目录](./features/env.md#资源文件路径) 中，文件格式与 `geoip.dat` 相同标签必须在文件中存在。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "network": {
                    "description": "可选的值有 \"tcp\"、\"udp\" 或 \"tcp,udp\"，当连接方式是指定的方式时，此规则生效。\n由于核心很明显只支持 tcp 和 udp 两种四层协议，所以一个仅包含 `\"network\": \"tcp,udp\"` 条件的路由可以用于 catch all 匹配任何流量。一个使用例子是放在所有路由规则的最末尾用于指定没有任何其他规则时使用的默认出站（否则核心默认走第一个）\n当然其他很明显能匹配任何流量的写法比如指定 1-65535 的 port 或者 0.0.0.0/0 + ::/0 的 ip 也有类似作用",
                    "enum": [
                        "tcp",
                        "tcp,udp",
                        "udp"
                    ],
                    "type": "string"
                },
                "outboundTag": {
                    "description": "对应一个 outbound 的标识。",
                    "type": "string"
                },
                "port": {
                    "description": "目标端口范围，有三种形式：\n- `\"a-b\"`：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。\n- `a`：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。\n- 以上两种形式的混合，以逗号 \",\" 分隔。形如：`\"53,443,1000-2000\"`。",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "protocol": {
                    "description": "一个数组，数组内每一项表示一种协议。当某一个协议匹配当前连接的协议类型时，此规则生效。\n`http` 仅支持 1.0 和 1.1 暂不支持 h2. (明文h2流量也非常少见)\n`tls` TLS 1.0 ~ 1.3\n`quic` 由于该协议复杂性，嗅探有时可能失效。\n`bittorrent` 只有最基础的嗅探，对很多加密和混淆可能不会奏效。\n::: tip\n必须开启入站代理中的 `sniffing` 选项, 才能嗅探出连接所使用的协议类型.\n:::",
                    "items": {
                        "enum": [
                            "bittorrent",
                            "http",
                            "quic",
                            "tls"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "ruleTag": {
                    "description": "可选，无实际作用，仅用于标识这条规则的名字\n如果设置，则命中该条规则时会在 Info 等级输出相关信息，用于调试路由具体命中了哪条规则。",
                    "type": "string"
                },
                "source": {
                    "description": "一个数组，数组内每一项代表一个 IP 范围，形式有 IP、CIDR、GeoIP 和从文件中加载 IP。当某一项匹配来源 IP 时，此规则生效。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "sourcePort": {
                    "description": "来源端口，有三种形式：\n- `\"a-b\"`：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。\n- `a`：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。\n- 以上两种形式的混合，以逗号 \",\" 分隔。形如：`\"53,443,1000-2000\"`。",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "type": {
                    "const": "field",
                    "description": "目前只支持`\"field\"`这一个选项。\n::: tip\nXray-core v1.8.7 或更高版本可省略该行。\n:::",
                    "type": "string"
                },
                "user": {
                    "description": "一个数组，数组内每一项是一个邮箱地址。当某一项匹配来源用户时，此规则生效。\n类似于域名，其也支持类似 `regexp:` 开头的正则进行匹配。（同样需要替换`\\`为`\\\\`, 见domain部分的解释）",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "SniffingObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"enabled\": true,\n  \"destOverride\": [\"http\", \"tls\", \"fakedns\"],\n  \"metadataOnly\": false,\n  \"domainsExcluded\": [],\n  \"routeOnly\": false\n}\n```",
            "properties": {
                "destOverride": {
                    "description": "当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。\n其中 `[\"fakedns+others\"]` 相当于 `[\"http\", \"tls\", \"quic\", \"fakedns\"]`，当 IP 地址处于 FakeIP 区间内但没有命中域名记录时会使用 `http`、`tls` 和 `quic` 进行匹配。此项仅在 `metadataOnly` 为 `false` 时有效。\n::: tip\nXray只会嗅探 `destOverride` 中协议的域名用作路由，如果只想进行嗅探用作路由而不想重置目标地址（如使用Tor浏览器时，重置目标地址会导致无法连接），请在这里添加对应的协议并启用 `routeOnly` 。\n:::",
                    "items": {
                        "enum": [
                            "fakedns",
                            "fakedns+others",
                            "http",
                            "quic",
                            "tls"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "domainsExcluded": {
                    "description": "一个域名列表，如果流量探测结果在这个列表中时，将 **不会** 重置目标地址。\n支持直接的域名（精确匹配），或 `regexp:` 开头后接正则表达式。\n::: tip\n填写一些域名，可能解决iOS 推送通知，米家智能设备，某些游戏（彩虹六号）语音问题。<br>\n如果需要排查某些问题的原因，可以通过关闭 `\"sniffing\"` 或者启用 `\"routeOnly\"` 来测试。\n:::\n```json\n\"domainsExcluded\": [\n    \"courier.push.apple.com\", // iOS 推送通知\n    \"Mijia Cloud\", // 米家智能设备\n    \"dlg.io.mi.com\"\n]\n\n```\n::: warning\n目前，`domainsExcluded` 不支持类似路由中的域名匹配方式。此选项未来可能会改变，不保证跨版本兼容。\n:::",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "enabled": {
                    "description": "是否开启流量探测。",
                    "type": "boolean"
                },
                "metadataOnly": {
                    "description": "当启用时，将仅使用连接的元数据嗅探目标地址。此时，除 `fakedns` 以外的 sniffer 将不能激活（包括 `fakedns+others`）。\n如果关闭仅使用元数据推断目标地址，此时客户端必须先发送数据，代理服务器才会实际建立连接。此行为与需要服务器首先发起第一个消息的协议不兼容，如 SMTP 协议。",
                    "type": "boolean"
                },
                "routeOnly": {
                    "description": "将嗅探得到的域名仅用于路由，代理目标地址仍为 IP。默认值为 `false`。\n此项需要开启 `destOverride` 使用。\n::: tip\n在能保证 **被代理连接能得到正确的 DNS 解析** 时，使用 `routeOnly` 且开启 `destOverride` 的同时，将路由匹配策略 `domainStrategy` 设置为 `AsIs` 即可实现全程无 DNS 解析进行域名及 IP 分流。此时遇到 IP 规则匹配时使用的 IP 为域名原始 IP。\n:::",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "SockoptObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"mark\": 0,\n  \"tcpMaxSeg\": 1440,\n  \"tcpFastOpen\": false,\n  \"tproxy\": \"off\",\n  \"domainStrategy\": \"AsIs\",\n  \"dialerProxy\": \"\",\n  \"acceptProxyProtocol\": false,\n  \"tcpKeepAliveInterval\": 0,\n  \"tcpKeepAliveIdle\": 300,\n  \"tcpUserTimeout\": 10000,\n  \"tcpcongestion\": \"bbr\",\n  \"interface\": \"wg0\",\n  \"V6Only\": false,\n  \"tcpWindowClamp\": 600\n  \"tcpMptcp\": false,\n  \"tcpNoDelay\": false,\n  \"customSockopt\": []\n}\n```",
            "properties": {
                "V6Only": {
                    "description": "填写 `true` 时，监听 `::` 地址仅接受 IPv6 连接。仅支持 Linux。",
                    "type": "boolean"
                },
                "acceptProxyProtocol": {
                    "description": "仅用于 inbound，指示是否接收 PROXY protocol。\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) 专用于传递请求的真实来源 IP 和端口，**若你不了解它，请先忽略该项**。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 `true` 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。",
                    "type": "boolean"
                },
                "customSockopt": {
                    "description": "一个数组，用于高级用户指定需要的任何 sockopt, 理论上上述所有与连接有关的设置均可以在此等价设置, 自然也可以设置Linux中存在但是核心未添加的其他选项，下方示例等价于核心中的 `\"tcpcongestion\": \"bbr\"`\n使用前请确保你了解 Linux Socket 编程。\n```json\n\"customSockopt\": [\n  {\n    \"type\": \"str\",\n    \"level\":\"6\",\n    \"opt\": \"13\",\n    \"value\": \"bbr\"\n  }\n]\n```",
                    "items": {},
                    "type": "array"
                },
                "dialerProxy": {
                    "const": "",
                    "description": "一个出站代理的标识。当值不为空时，将使用指定的 outbound 发出连接。 此选项可用于支持底层传输方式的链式转发。\n::: danger\n此选项与 ProxySettingsObject.Tag 不兼容\n:::",
                    "type": "string"
                },
                "domainStrategy": {
                    "const": "AsIs",
                    "description": "在之前的版本中，当 Xray 尝试使用域名建立系统连接时，域名的解析由系统完成，不受 Xray\n控制。这导致了在 [非标准 Linux 环境中无法解析域名](https://github.com/v2ray/v2ray-core/issues/1909) 等问题。为此，Xray 1.3.1 为 Sockopt 引入了 Freedom\n中的 domainStrategy，解决了此问题。\n默认值 `\"AsIs\"`。\n当目标地址为域名时，配置相应的值，Outbound 连接远端服务器的行为模式如下：\n- 当使用 `\"AsIs\"` 时，Xray 将直接使用 go 自带的 Dial 发起连接，优先级固定为 RFC6724 的默认值(不会遵守 gai.conf 等配置) (人话：IPv6 优先)。\n- 当填写其他值时，将使用 Xray-core [内置 DNS 服务器](../dns.md) 服务器进行解析。若不存在DNSObject，则使用系统DNS。若有多个符合条件的IP地址时，核心会随机选择一个IP作为目标IP。\n- `\"IPv4\"` 代表尝试仅使用IPv4进行连接，`\"IPv4v6\"` 代表尝试使用IPv4或IPv6连接，但对于双栈域名，使用IPv4。（v4v6调换后同理，不再赘述）\n- 当在内置DNS设置了 `\"queryStrategy\"` 后，实际行为将会与这个选项取并，只有都被包含的IP类型才会被解析，如 `\"queryStrategy\": \"UseIPv4\"` `\"domainStrategy\": \"UseIP\"`，实际上等同于 `\"domainStrategy\": \"UseIPv4\"`。\n- 当使用 `\"Use\"` 开头的选项时，若解析结果不符合要求（如，域名只有IPv4解析结果但使用了UseIPv6），则会回落回AsIs。\n- 当使用 `\"Force\"` 开头的选项时，若解析结果不符合要求，则该连接会无法建立。\n::: tip TIP\n当使用 `\"UseIP\"`、`\"ForceIP\"` 模式时，并且 [出站连接配置](../outbound.md#outboundobject) 中指定了 `sendThrough` 时，核心会根据 `sendThrough` 的值自动判断所需的 IP 类型，IPv4 或 IPv6。若手动指定了单种IP类型（如UseIPv4），但与 `sendThrough` 指定的本地地址不匹配，将会导致连接失败。\n:::\n::: danger\n启用了此功能后，不当的配置可能会导致死循环。\n一句话版本：连接到服务器，需要等待 DNS 查询结果；完成 DNS 查询，需要连接到服务器。\n> Tony: 先有鸡还是先有蛋?\n详细解释：\n1. 触发条件：代理服务器（proxy.com）。内置 DNS 服务器，非 Local 模式。\n2. Xray 尝试向 proxy.com 建立 TCP 连接 **前** ，通过内置 DNS 服务器查询 proxy.com。\n3. 内置 DNS 服务器向 dns.com 建立连接，并发送查询，以获取 proxy.com 的 IP。\n4. **不当的** 的路由规则，导致 proxy.com 代理了步骤 3 中发出的查询。\n5. Xray 尝试向 proxy.com 建立另一个 TCP 连接。\n6. 在建立连接前，通过内置 DNS 服务器查询 proxy.com。\n7. 内置 DNS 服务器复用步骤 3 中的连接，发出查询。\n8. 问题出现。步骤 3 中连接的建立，需要等待步骤 7 中的查询结果；步骤 7 完成查询，需要等待步骤 3 中的连接完全建立。\n9. Good Game！\n解决方案：\n- 改内置 DNS 服务器的分流。\n- 用 Hosts。\n- ~~如果你还是不知道解决方案，就别用这个功能了。~~\n因此，**不建议** 经验不足的用户擅自使用此功能。\n:::",
                    "type": "string"
                },
                "interface": {
                    "const": "",
                    "description": "指定绑定出口网卡名称，支持 linux / iOS / Mac OS / Windows。",
                    "type": "string"
                },
                "level": {
                    "const": "",
                    "description": "可选，协议级别，用于指定生效范围，默认为6, 即TCP.",
                    "type": "string"
                },
                "mark": {
                    "description": "一个整数。当其值非零时，在 outbound 连接上以此数值标记 SO_MARK。\n- 仅适用于 Linux 系统。\n- 需要 CAP_NET_ADMIN 权限。",
                    "type": "number"
                },
                "opt": {
                    "const": "",
                    "description": "操作的选项名称，使用十进制(此处示例为 TCP_CONGESTION 的值 定义为 0xd 转换为10进制即为13)",
                    "type": "string"
                },
                "tcpFastOpen": {
                    "description": "是否启用 [TCP Fast Open](https://zh.wikipedia.org/wiki/TCP%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80)。\n当其值为 `true` 或`正整数`时，启用 TFO；当其值为 `false` 或`负数`时，强制关闭 TFO；当此项不存在或为 `0` 时，使用系统默认设置。 可用于 inbound/outbound。\n- 仅在以下版本（或更新版本）的操作系统中可用:\n\n  - Linux 3.16：需要通过内核参数 `net.ipv4.tcp_fastopen` 进行设定，此参数是一个 bitmap，`0x1` 代表客户端允许启用，`0x2` 代表服务器允许启用；默认值为 `0x1`，如果服务器要启用\n    TFO，请把此内核参数值设为 `0x3`。\n  - ~~Windows 10 (1607)~~（实现不正确）\n  - Mac OS 10.11 / iOS 9（需要测试）\n  - FreeBSD 10.3 (Server) / 12.0 (Client)：需要把内核参数 `net.inet.tcp.fastopen.server_enabled`\n    以及 `net.inet.tcp.fastopen.client_enabled` 设为 `1`。（需要测试）\n\n- 对于 Inbound，此处所设定的`正整数`代表 [待处理的 TFO 连接请求数上限](https://tools.ietf.org/html/rfc7413#section-5.1) ，**注意并非所有操作系统都支持在此设定**：\n\n  - Linux / FreeBSD：此处的设定的`正整数`值代表上限，可接受的最大值为 2147483647，为 `true` 时将取 `256`；注意在 Linux，`net.core.somaxconn`\n    会限制此值的上限，如果超过了 `somaxconn`，请同时提高 `somaxconn`。\n  - Mac OS：此处为 `true` 或`正整数`时，仅代表启用 TFO，上限需要通过内核参数 `net.inet.tcp.fastopen_backlog` 单独设定。\n  - Windows：此处为 `true` 或`正整数`时，仅代表启用 TFO。\n\n- 对于 Outbound，设定为 `true` 或`正整数`在任何操作系统都仅表示启用 TFO。",
                    "type": [
                        "number",
                        "boolean"
                    ]
                },
                "tcpKeepAliveIdle": {
                    "description": "TCP 空闲时间阈值，单位为秒。当 TCP 连接空闲时间达到这个阈值时，将开始发送 Keep-Alive 探测包。\n它是连接正常时候的心跳包。\n不配置此项或配置为 0 表示使用 Go 默认值。\n::: tip\n填负数时，如 `-1`，不启用 TCP 保持活跃。\n:::",
                    "type": "number"
                },
                "tcpKeepAliveInterval": {
                    "description": "TCP 保持活跃的数据包发送间隔，单位为秒。~~该设置仅适用于 Linux 下。~~\n它是连接不正常（未收到 ack）时候的心跳包。\n不配置此项或配置为 0 表示使用 Go 默认值。\n::: tip\n填负数时，如 `-1`，不启用 TCP 保持活跃。\n:::",
                    "type": "number"
                },
                "tcpMaxSeg": {
                    "description": "用于设置 TCP 数据包的最大传输单元。",
                    "type": "number"
                },
                "tcpMptcp": {
                    "description": "Xray-core v1.8.6 新增参数。<br>\n默认值 `false`，填写 `true` 时，启用 [Multipath TCP](https://en.wikipedia.org/wiki/Multipath_TCP)，需在服务端和客户端配置中同时启用。\n当前仅支持Linux，需要Linux Kernel 5.6及以上。",
                    "type": "boolean"
                },
                "tcpNoDelay": {
                    "description": "该选项已被删除，因为 golang 默认启用 TCP no delay。 相反地，如果想要禁用，请通过使用 customSockopt 禁用。",
                    "type": "boolean"
                },
                "tcpUserTimeout": {
                    "description": "单位为毫秒。详细介绍：https://github.com/grpc/proposal/blob/master/A18-tcp-user-timeout.md",
                    "type": "number"
                },
                "tcpWindowClamp": {
                    "description": "绑定通告的 windows 大小为该值。内核会在它与 SOCK_MIN_RCVBUF/2 之间选一个最大值。",
                    "type": "number"
                },
                "tcpcongestion": {
                    "const": "",
                    "description": "TCP 拥塞控制算法。仅支持 Linux。\n不配置此项表示使用系统默认值。\n::: tip 常见的算法\n- bbr（推荐）\n- cubic\n- reno\n:::\n::: tip\n执行命令 `sysctl net.ipv4.tcp_congestion_control` 获取系统默认值。\n:::",
                    "type": "string"
                },
                "tproxy": {
                    "description": "是否开启透明代理（仅适用于 Linux）。\n- `\"redirect\"`：使用 Redirect 模式的透明代理。支持所有基于 IPv4/6 的 TCP 连接。\n- `\"tproxy\"`：使用 TProxy 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。\n- `\"off\"`：关闭透明代理。\n透明代理需要 Root 或 `CAP\\_NET\\_ADMIN` 权限。\n::: danger\n当 [Dokodemo-door](./inbounds/dokodemo.md) 中指定了 `followRedirect`为`true`，且 Sockopt 设置中的`tproxy` 为空时，Sockopt\n设置中的`tproxy` 的值会被设为 `\"redirect\"`。\n:::",
                    "enum": [
                        "off",
                        "redirect",
                        "tproxy"
                    ],
                    "type": "string"
                },
                "type": {
                    "const": "",
                    "description": "必填，设置的类型，目前可选int或str.",
                    "type": "string"
                },
                "value": {
                    "const": "",
                    "description": "要设置的选项值，此处示例为设置为bbr.\n当 type 指定为 int 时需要使用十进制数字。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "StatsObject": {
            "additionalProperties": {},
            "description": "`StatsObject` 对应配置文件的 `stats` 项。\n```json\n{\n  \"stats\": {}\n}\n```\n目前统计信息不需要任何参数，只要 `StatsObject` 项存在，内部的统计即会开启。\n开启了统计以后, 只需在 [Policy](./policy.md) 中开启对应的项，就可以统计对应的数据。\n可以用 `xray api` 的相关命令获取统计信息.\n目前已有的统计信息如下：\n- 用户数据\n\n  - `user>>>[email]>>>traffic>>>uplink`\n\n    特定用户的上行流量，单位字节。\n\n  - `user>>>[email]>>>traffic>>>downlink`\n\n    特定用户的下行流量，单位字节。\n::: tip\n如果对应用户没有指定 Email，则不会开启统计。\n:::\n- 全局数据\n\n  - `inbound>>>[tag]>>>traffic>>>uplink`\n\n    特定 inbound 的上行流量，单位字节。\n\n  - `inbound>>>[tag]>>>traffic>>>downlink`\n\n    特定 inbound 的下行流量，单位字节。\n\n  - `outbound>>>[tag]>>>traffic>>>uplink`\n\n    特定 outbound 的上行流量，单位字节。\n\n  - `outbound>>>[tag]>>>traffic>>>downlink`\n\n    特定 outbound 的下行流量，单位字节。",
            "type": "object"
        },
        "StrategyObject": {
            "additionalProperties": {},
            "description": "```json\n{\n    \"type\": \"roundRobin\",\n    \"settings\": {}\n}\n```",
            "properties": {
                "settings": {
                    "$ref": "#/definitions/StrategySettingsObject"
                },
                "type": {
                    "description": "- `random` 默认值。随机选择匹配到的出站代理。\n- `roundRobin` 按顺序选择匹配到的出站代理。\n- `leastPing` 根据连接观测结果选择延迟最小的匹配到的出站代理。需要添加 [observatory](./observatory.md#observatoryobject) 或者 [burstObservatory](./observatory.md#burstobservatoryobject) 配置项。\n- `leastLoad` 根据连接观测结果选择最稳定的出站代理。需要添加 [observatory](./observatory.md#observatoryobject) 或者 [burstObservatory](./observatory.md#burstobservatoryobject) 配置项。",
                    "enum": [
                        "leastLoad",
                        "leastPing",
                        "random",
                        "roundRobin"
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "StrategySettingsObject": {
            "additionalProperties": {},
            "description": "这是一个可选配置项，不同负载均衡策略的配置格式有所不同。目前只有 `leastLoad` 负载均衡策略可以添加这个配置项。\n```json\n{\n    \"expected\": 2,\n    \"maxRTT\": \"1s\",\n    \"tolerance\": 0.01,\n    \"baselines\": [\"1s\"],\n    \"costs\": [{\n        \"regexp\": false,\n        \"match\": \"tag\",\n        \"value\": 0.5\n    }]\n}\n```",
            "properties": {
                "baselines": {
                    "description": "最高可接受的测速 RTT 标准差时长。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "costs": {
                    "description": "可选配置项，一个数组，可以给所有出站指定权重。",
                    "items": {},
                    "type": "array"
                },
                "expected": {
                    "description": "负载均衡器选出最优节点的个数，流量将在这几个节点中随机分配。",
                    "type": "number"
                },
                "match": {
                    "description": "匹配出站 `Tag`。",
                    "type": "string"
                },
                "maxRTT": {
                    "description": "最高可接受的测速 RTT 时长。",
                    "type": "string"
                },
                "regexp": {
                    "description": "是否用正则表达式选择出站 `Tag`。",
                    "type": "boolean"
                },
                "tolerance": {
                    "description": "最多可接受的测速失败比例，例如 0.01 指可接受百分之一测速失败。（似乎未实现）"
                },
                "value": {
                    "description": "权重值，值越大，对应节点越不易被选中。\n```json\n    \"routing\": {\n        \"rules\": [\n            {\n                \"inboundTag\": [\n                    \"in\"\n                ],\n                \"balancerTag\": \"round\"\n            }\n        ],\n        \"balancers\" : [\n            {\n                \"selector\": [\n                    \"out\"\n                ],\n                \"strategy\": {\n                    \"type\":\"roundRobin\"\n                },\n                \"tag\": \"round\"\n            }\n        ]\n    }\n\n    \"inbounds\": [\n        {\n            // 入站配置\n            \"tag\": \"in\"\n        }\n    ]\n\n    \"outbounds\": [\n        {\n            // 出站配置\n            \"tag\": \"out1\"\n        },\n        {\n            // 出站配置\n            \"tag\": \"out2\"\n        }\n    ]\n```\n此列表预置于每一个 Xray 的安装包中，文件名为 `geosite.dat`。这个文件包含了一些常见的域名，使用方式：`geosite:filename`，如 `geosite:google` 表示对文件内符合 `google` 内包含的域名，进行路由筛选或 DNS 筛选。\n常见的域名有：\n- `category-ads`：包含了常见的广告域名。\n- `category-ads-all`：包含了常见的广告域名，以及广告提供商的域名。\n- `cn`：相当于 `geolocation-cn` 和 `tld-cn` 的合集。\n- `apple`：包含了 Apple 旗下绝大部分域名。\n- `google`：包含了 Google 旗下绝大部分域名。\n- `microsoft`：包含了 Microsoft 旗下绝大部分域名。\n- `facebook`：包含了 Facebook 旗下绝大部分域名。\n- `twitter`：包含了 Twitter 旗下绝大部分域名。\n- `telegram`：包含了 Telegram 旗下绝大部分域名。\n- `geolocation-cn`：包含了常见的大陆站点域名。\n- `geolocation-!cn`：包含了常见的非大陆站点域名。\n- `tld-cn`：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 `.cn`、`.中国` 结尾的域名。\n- `tld-!cn`：包含了非中国大陆使用的顶级域名，如以 `.tw`（台湾）、`.jp`（日本）、`.sg`（新加坡）、`.us`（美国）`.ca`（加拿大）等结尾的域名。\n你也可以在这里查看完整的域名列表 [Domain list community](https://github.com/v2fly/domain-list-community)。"
                }
            },
            "type": "object"
        },
        "StreamSettingsObject": {
            "additionalProperties": {},
            "description": "`StreamSettingsObject` 对应入站或出站中的 `streamSettings` 项。每一个入站或出站都可以分别配置不同的传输配置，都可以设置 `streamSettings` 来进行一些传输的配置。\n```json\n{\n  \"network\": \"raw\",\n  \"security\": \"none\",\n  \"tlsSettings\": {},\n  \"realitySettings\": {},\n  \"rawSettings\": {},\n  \"xhttpSettings\": {},\n  \"kcpSettings\": {},\n  \"grpcSettings\": {},\n  \"wsSettings\": {},\n  \"httpupgradeSettings\": {},\n  \"sockopt\": {\n    \"mark\": 0,\n    \"tcpMaxSeg\": 1440,\n    \"tcpFastOpen\": false,\n    \"tproxy\": \"off\",\n    \"domainStrategy\": \"AsIs\",\n    \"dialerProxy\": \"\",\n    \"acceptProxyProtocol\": false,\n    \"tcpKeepAliveInterval\": 0,\n    \"tcpKeepAliveIdle\": 300,\n    \"tcpUserTimeout\": 10000,\n    \"tcpCongestion\": \"bbr\",\n    \"interface\": \"wg0\",\n    \"v6only\": false,\n    \"tcpWindowClamp\": 600,\n    \"tcpMptcp\": false,\n    \"tcpNoDelay\": false\n  }\n}\n```",
            "properties": {
                "grpcSettings": {
                    "$ref": "#/definitions/GRPCObject",
                    "description": "当前连接的 gRPC 配置，仅当此连接使用 gRPC 时有效。"
                },
                "httpupgradeSettings": {
                    "$ref": "#/definitions/HttpUpgradeObject",
                    "description": "当前连接的 HTTPUpgrade 配置，仅当此连接使用 HTTPUpgrade 时有效。"
                },
                "kcpSettings": {
                    "$ref": "#/definitions/KcpObject",
                    "description": "当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。"
                },
                "network": {
                    "description": "连接的数据流所使用的传输方式类型，默认值为 `\"raw\"`。\n::: tip\nv24.9.30 版本后，为了更贴近实际行为，TCP 传输方式已更名为 RAW。为了兼容性，`\"network\": \"raw\"` 和 `\"network\": \"tcp\"`，`rawSettings` 和 `tcpSettings` 互为别名。\n:::",
                    "enum": [
                        "grpc",
                        "httpupgrade",
                        "kcp",
                        "raw",
                        "ws",
                        "xhttp"
                    ],
                    "type": "string"
                },
                "rawSettings": {
                    "$ref": "#/definitions/RawObject",
                    "description": "当前连接的 RAW 配置，仅当此连接使用 RAW 时有效。"
                },
                "realitySettings": {
                    "$ref": "#/definitions/RealityObject",
                    "description": "Reality 配置。Reality 是 Xray 的原创黑科技。 Reality 比 TLS 的安全性更高, 配置方式也和 TLS 一致.\n::: tip\nReality 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性。 启用 Reality 并且配置合适的 XTLS Vision 流控模式, 可以\n达到数倍甚至十几倍的性能提升。\n:::"
                },
                "security": {
                    "description": "是否启用传输层加密，支持的选项有\n- `\"none\"` 表示不加密（默认值）\n- `\"tls\"` 表示使用 [TLS](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)。\n- `\"reality\"` 表示使用 REALITY。",
                    "enum": [
                        "none",
                        "reality",
                        "tls"
                    ],
                    "type": "string"
                },
                "sockopt": {
                    "$ref": "#/definitions/SockoptObject",
                    "description": "透明代理相关的具体配置。"
                },
                "tlsSettings": {
                    "$ref": "#/definitions/TLSObject",
                    "description": "TLS 配置。TLS 由 Golang 提供，通常情况下 TLS 协商的结果为使用 TLS 1.3，不支持 DTLS。"
                },
                "wsSettings": {
                    "$ref": "#/definitions/WebSocketObject",
                    "description": "当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。"
                },
                "xhttpSettings": {
                    "description": "当前连接的 XHTTP 配置，仅当此连接使用 XHTTP 时有效。"
                }
            },
            "type": "object"
        },
        "SystemPolicyObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"statsInboundUplink\": false,\n  \"statsInboundDownlink\": false,\n  \"statsOutboundUplink\": false,\n  \"statsOutboundDownlink\": false\n}\n```",
            "properties": {
                "statsInboundDownlink": {
                    "description": "当值为 `true` 时，开启所有入站代理的下行流量统计。",
                    "type": "boolean"
                },
                "statsInboundUplink": {
                    "description": "当值为 `true` 时，开启所有入站代理的上行流量统计。",
                    "type": "boolean"
                },
                "statsOutboundDownlink": {
                    "description": "当值为 `true` 时，开启所有出站代理的下行流量统计。",
                    "type": "boolean"
                },
                "statsOutboundUplink": {
                    "description": "当值为 `true` 时，开启所有出站代理的上行流量统计。",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "TLSObject": {
            "additionalProperties": {},
            "description": "```json\n{\n  \"serverName\": \"xray.com\",\n  \"serverNameToVerify\":\"\",\n  \"rejectUnknownSni\": false,\n  \"allowInsecure\": false,\n  \"alpn\": [\"h2\", \"http/1.1\"],\n  \"minVersion\": \"1.2\",\n  \"maxVersion\": \"1.3\",\n  \"cipherSuites\": \"此处填写你需要的加密套件名称,每个套件名称之间用:进行分隔\",\n  \"certificates\": [],\n  \"disableSystemRoot\": false,\n  \"enableSessionResumption\": false,\n  \"fingerprint\": \"\",\n  \"pinnedPeerCertificateChainSha256\": [\"\"],\n  \"curvePreferences\": [\"\"],\n  \"masterKeyLog\": \"\"\n}\n```",
            "properties": {
                "allowInsecure": {
                    "description": "是否允许不安全连接（仅用于客户端）。默认值为 `false`。\n当值为 `true` 时，Xray 不会检查远端主机所提供的 TLS 证书的有效性。\n::: danger\n出于安全性考虑，这个选项不应该在实际场景中选择 true，否则可能遭受中间人攻击。\n:::",
                    "type": "boolean"
                },
                "alpn": {
                    "description": "一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为 `[\"h2\", \"http/1.1\"]`。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "certificates": {
                    "description": "证书列表，其中每一项表示一个证书（建议 fullchain）。\n::: tip\n如果要在 ssllibs 或者 myssl 获得 A/A+ 等级的评价,\n请参考 [这里](https://github.com/XTLS/Xray-core/discussions/56#discussioncomment-215600).\n:::",
                    "items": {
                        "$ref": "#/definitions/CertificateObject"
                    },
                    "type": "array"
                },
                "cipherSuites": {
                    "description": "CipherSuites 用于配置受支持的密码套件列表, 每个套件名称之间用:进行分隔.\n你可以在 [这里](https://golang.org/src/crypto/tls/cipher_suites.go#L500)或 [这里](https://golang.org/src/crypto/tls/cipher_suites.go#L44)\n找到 golang 加密套件的名词和说明\n::: danger\n以上两项配置为非必要选项，正常情况下不影响安全性 在未配置的情况下 golang 根据设备自动选择. 若不熟悉, 请勿配置此选项, 填写不当引起的问题自行负责\n:::",
                    "type": "string"
                },
                "curvePreferences": {
                    "description": "一个字符串数组，指定 TLS 握手执行ECDHE时偏好的曲线。支持的曲线列表如下（大小写不敏感）\n```\nCurveP256\nCurveP384\nCurveP521\nX25519\nx25519Kyber768Draft00\n```\n比如设置为 `\"curvePreferences\":[\"x25519Kyber768Draft00\"]` 可以启用实验性的后量子算法。由于还是草案阶段该字段随时可能变化。",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "disableSystemRoot": {
                    "description": "是否禁用操作系统自带的 CA 证书。默认值为 `false`。\n当值为 `true` 时，Xray 只会使用 `certificates` 中指定的证书进行 TLS 握手。当值为 `false` 时，Xray 只会使用操作系统自带的 CA 证书进行 TLS 握手。",
                    "type": "boolean"
                },
                "enableSessionResumption": {
                    "description": "是否启用会话恢复，默认禁用，只有服务端和客户端都启用时候才会尝试协商会话恢复。\n如果协商成功将可以不在握手过程中传输证书。稍微节省一点点握手时间（几乎可以忽略不计）\n注意，这不是 TLS 0RTT, gotls 尚未支持此功能，这不会减少 TLS 握手的 RTT.",
                    "type": "boolean"
                },
                "fingerprint": {
                    "description": "此参数用于配置指定 `TLS Client Hello` 的指纹。当其值为空时，表示不启用此功能。启用后，Xray 将通过 uTLS 库 **模拟** `TLS` 指纹，或随机生成。支持三种配置方式：\n1. 常见浏览器最新版本的 TLS 指纹 包括\n- `\"chrome\"`\n- `\"firefox\"`\n- `\"safari\"`\n- `\"ios\"`\n- `\"android\"`\n- `\"edge\"`\n- `\"360\"`\n- `\"qq\"`\n2. 在 xray 启动时自动生成一个指纹\n- `\"random\"`: 在较新版本的浏览器里随机抽取一个\n- `\"randomized\"`: 完全随机生成一个独一无二的指纹 (100% 支持 TLS 1.3 使用 X25519)\n3. 使用 uTLS 原生指纹变量名 例如`\"HelloRandomizedNoALPN\"` `\"HelloChrome_106_Shuffle\"`。完整名单见 [uTLS 库](https://github.com/refraction-networking/utls/blob/master/u_common.go#L434)\n::: tip\n此功能仅 **模拟** `TLS Client Hello` 的指纹，行为、其他指纹与 Golang 相同。如果你希望更加完整地模拟浏览器 `TLS`\n指纹与行为，可以使用 [Browser Dialer](./transports/websocket.md#browser-dialer)。\n:::\n::: tip\n当使用此功能时，TLS 的部分影响TLS指纹的选项将被 utls 库覆盖不再生效，列如ALPN。\n会被传递的参数有\n`\"serverName\" \"allowInsecure\" \"disableSystemRoot\" \"pinnedPeerCertificateChainSha256\" \"masterKeyLog\"`\n:::",
                    "type": "string"
                },
                "masterKeyLog": {
                    "description": "(Pre)-Master-Secret log 文件路径，可用于Wireshark等软件解密Xray发送的TLS连接，暂不支持与utls一起使用。",
                    "type": "string"
                },
                "maxVersion": {
                    "description": "maxVersion 为可接受的最大 TLS 版本。",
                    "type": "string"
                },
                "minVersion": {
                    "description": "minVersion 为可接受的最小 TLS 版本。",
                    "type": "string"
                },
                "pinnedPeerCertificateChainSha256": {
                    "description": "用于指定远程服务器的证书链 SHA256 散列值，使用标准编码格式。仅有当服务器端证书链散列值符合设置项中之一时才能成功建立 TLS 连接。\n注意：只有验证证书有效后，核心才会进行此检查，比如如果自签证书并在此指定，核心在验证证书失败后会直接断开连接而不会进行这个检查，如有类似需求可以考虑开启 `allowInsecure` 跳过签名验证然后便可以正常工作\n在连接因为此配置失败时，会展示远程服务器证书散列值。\n::: danger\n不建议使用这种方式获得证书链散列值，因为在这种情况下将没有机会验证此时服务器提供的证书是否为真实证书，进而不保证获得的证书散列值为期望的散列值。\n:::\n::: tip\n如果需要获得证书的散列值，应在命令行中运行 `xray tls certChainHash --cert <cert.pem>` 来获取，`<cert.pem>` 应替换为实际证书文件路径。\n:::",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "rejectUnknownSni": {
                    "description": "当值为 `true` 时，服务端接收到的 SNI 与证书域名不匹配即拒绝 TLS 握手，默认为 false。",
                    "type": "boolean"
                },
                "serverName": {
                    "description": "指定服务器端证书的域名，在连接由 IP 建立时有用。\n当留空时，自动使用address中的值（如果是域名），该值同时用于校验服务端证书是否有效。\n::: tip\n如上所述，因为该值同时用于校验服务端证书是否有效，如果出于特殊目的将其修改为与服务端证书域名不一致的需要需要开启 `allowInsecure` 否则会导致证书认证失败。出于安全考虑我们不推荐长期使用这种方法，如果想要安全地伪造SNI，请考虑使用REALITY。\n特别地，当客户端设置其为IP地址时，xray不会发送SNI，同样的要使用此功能也必须同时开启 `allowInsecure`\n:::",
                    "type": "string"
                },
                "serverNameToVerify": {
                    "description": "仅客户端，用于校验证书使用的 SNI, 将会覆盖本用于校验的 `serverName`, 用于域前置等特殊目的。 相较于之前的修改 `serverName` 并开启 `allowInsecure` 更加安全，因为其仍会执行证书签名验证。但是这是 utls 的专属功能，需要设置 `fingerprint` 启用 utls 以使用。",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "WebSocketObject": {
            "additionalProperties": {},
            "description": "`WebSocketObject` 对应传输配置的 `wsSettings` 项。\n```json\n{\n  \"acceptProxyProtocol\": false,\n  \"path\": \"/\",\n  \"host\": \"xray.com\",\n  \"headers\": {\n    \"key\": \"value\"\n  },\n  \"heartbeatPeriod\": 10\n}\n```",
            "properties": {
                "acceptProxyProtocol": {
                    "description": "仅用于 inbound，指示是否接收 PROXY protocol。\n[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) 专用于传递请求的真实来源 IP 和端口，**若你不了解它，请先忽略该项**。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 `true` 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。",
                    "type": "boolean"
                },
                "headers": {
                    "$ref": "#/definitions/Record<string,string>",
                    "description": "仅客户端，自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。"
                },
                "heartbeatPeriod": {
                    "description": "指定间隔固定时间发送一个 Ping message 保活连接。不指定或指定为0时不发送 Ping message，为当前默认行为。\n使用浏览器处理 TLS，详见 [Browser Dialer](../features/browser_dialer.md)",
                    "type": "number"
                },
                "host": {
                    "description": "WebSocket 的HTTP请求中所发送的host，默认值为空。若服务端值为空时，不验证客户端发送来的host值。\n当在服务端指定该值，或在 ```headers``` 中指定host，将会校验与客户端请求host是否一致。\n客户端选择发送的host优先级 ```host``` >  ```headers``` > ```address```",
                    "type": "string"
                },
                "path": {
                    "description": "WebSocket 所使用的 HTTP 协议路径，默认值为 `\"/\"`。\n如果客户端路径中包含 `ed` 参数(如 ```/mypath?ed=2560```)，将会启用 `Early Data` 以降低延迟，在升级的同时使用 `Sec-WebSocket-Protocol` 头承载首包数据，其值为首包长度阈值。如果首包长度超过此值，就不会启用 `Early Data`。推荐值为 2560，最大值为8192，过大的值可能导致部分兼容问题，如果遇到兼容性问题，可以尝试调低阈值。",
                    "type": "string"
                }
            },
            "type": "object"
        }
    },
    "properties": {
        "api": {
            "$ref": "#/definitions/ApiObject",
            "description": "提供了一些 API 接口供远程调用。"
        },
        "burstObservatory": {
            "$ref": "#/definitions/BurstObservatoryObject",
            "description": "并发连接观测。探测出站代理的连接状态。"
        },
        "dns": {
            "$ref": "#/definitions/DnsObject",
            "description": "内置的 DNS 服务器. 如果没有配置此项，则使用系统的 DNS 设置。"
        },
        "fakedns": {
            "description": "FakeDNS 配置。可配合透明代理使用，以获取实际域名。"
        },
        "inbounds": {
            "description": "一个数组，每个元素是一个入站连接配置。",
            "items": {
                "$ref": "#/definitions/InboundObject"
            },
            "type": "array"
        },
        "log": {
            "$ref": "#/definitions/LogObject",
            "description": "日志配置，控制 Xray 输出日志的方式."
        },
        "metrics": {
            "description": "metrics 配置。更直接（希望更好）的统计导出方式。"
        },
        "observatory": {
            "$ref": "#/definitions/ObservatoryObject",
            "description": "后台连接观测。探测出站代理的连接状态。"
        },
        "outbounds": {
            "description": "一个数组，每个元素是一个出站连接配置。",
            "items": {
                "$ref": "#/definitions/OutboundObject"
            },
            "type": "array"
        },
        "policy": {
            "$ref": "#/definitions/PolicyObject",
            "description": "本地策略，可以设置不同的用户等级和对应的策略设置。"
        },
        "reverse": {
            "$ref": "#/definitions/ReverseObject",
            "description": "反向代理。可以把服务器端的流量向客户端转发，即逆向流量转发。"
        },
        "routing": {
            "$ref": "#/definitions/RoutingObject",
            "description": "路由功能。可以设置规则分流数据从不同的 outbound 发出."
        },
        "stats": {
            "$ref": "#/definitions/StatsObject",
            "description": "用于配置流量数据的统计。"
        },
        "transport": {
            "description": "用于配置 Xray 其它服务器建立和使用网络连接的方式。"
        }
    },
    "type": "object"
}

